<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ksxy&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://offensiveyy.github.io/"/>
  <updated>2018-03-10T15:30:16.533Z</updated>
  <id>http://offensiveyy.github.io/</id>
  
  <author>
    <name>空山新雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Https之SSL/TLS握手</title>
    <link href="http://offensiveyy.github.io/2018/03/10/Https%E4%B9%8BSSL-TSL%E6%8F%A1%E6%89%8B/"/>
    <id>http://offensiveyy.github.io/2018/03/10/Https之SSL-TSL握手/</id>
    <published>2018-03-10T13:02:48.000Z</published>
    <updated>2018-03-10T15:30:16.533Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于HTTPS"><a href="#关于HTTPS" class="headerlink" title="关于HTTPS"></a>关于HTTPS</h3><p>  相信对于大多数开发人员，Https并不陌生，在http协议基础上套上一个加密解密的过程，就是Https，而完成加密解密的部分就是SSL(Secure Sockets Layer, 安全套字节层)。<br>  <a href="https://i.loli.net/2018/03/10/5aa3dc30b9086.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/10/5aa3dc30b9086.png" alt="https协议.png"></a></p><h3 id="关于TSL-SSL"><a href="#关于TSL-SSL" class="headerlink" title="关于TSL/SSL"></a>关于TSL/SSL</h3><p>  1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是没有发布；之后在1995年正式发布了SSL 2.0, 但很快发现严重漏；1996年，SSL 3.0版问世，并得到大规模应用。之后在1999年，由互联网标准化组织ISOC接管，并升级成为TSL(Transport Layer Security)。所以TSL和SSL是同一个协议。</p><h3 id="加密解密基本原理"><a href="#加密解密基本原理" class="headerlink" title="加密解密基本原理"></a>加密解密基本原理</h3><p>  TSL在不同的阶段使用了不同的加密方式。</p><p>  在握手阶段，使用的是公钥加密法，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。握手的主要目的是完成客户端与服务端之间的验证，同时约定一个随机密钥种子；</p><p>  在数据传输阶段，所用的加密方式为对称加密(AES)，经过握手阶段后，客户端和服务端保存着同一个密钥种，在之后的数据传输中，客户端和服务器端同时使用给密钥进行加密解密。同时，该密钥还被用于HMAC的key，用于数据完整性、可靠性的校验。</p><p>  <strong>问题：握手阶段，如何保证公钥不被篡改？</strong></p><p>  实际上，客户端一开始向服务端请求的是一个数字证书，数字证书中包含了公钥、该数字证书的签发机构、改签发机构的数字签名等信息。客户端通过检验证书的合法性来判断包含公钥是否可信。</p><p>  至于为啥数字证书的方案可行，这就要涉及到信息安全的理论知识了，这里不深入。签发证书的机构如果是权威机构CA，则该证书是CA证书，可信任。如果不是，则提示证书不可信。</p><p>  <strong>问题：为啥在数据传输阶段不用公钥加密？</strong></p><p>  因为公钥加密实际上就的非对称加密，非对称加密的数序理论依据导致了非对称加密的成本比较高，所以通常只用于少量数据的传输，而对称加密是通过非线性变换等方式实现的加密，加密成本比较低，性能相对非对称加密高。</p><h3 id="SSL-TLS握手"><a href="#SSL-TLS握手" class="headerlink" title="SSL/TLS握手"></a>SSL/TLS握手</h3><p>  从上面的原理可总结出SSL/TLS握手的过程：</p><ol><li>客户端向服务器端索要并验证公钥。</li><li>双方协商生成”对话密钥”。</li></ol><p><strong>握手详细过程</strong>：</p><p><a href="https://i.loli.net/2018/03/10/5aa3f5f34a00f.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/10/5aa3f5f34a00f.png" alt="SSL握手.png"></a></p><ol><li><p>客户端发出请求（ClientHello）</p><p>客户端先向服务器发出加密通信的请求，请求内容：<br>支持的协议版本（比如TLS 1.0版）、随机数A（用于生产对称密钥）、支持的加密方法（比如RSA公钥加密）。</p></li><li><p>服务器回应（SeverHello）</p><p>服务器收到客户端请求后，向客户端发出回应，回应内容：<br>确认使用的协议版本、随机数B、确认使用的加密方法、服务器证书。</p><p>如果服务器需要验证客户端身份，还回要求客户端提供证书，该证书通常需要提前安装。</p></li><li><p>客户端回应</p><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从证书中取出服务器的公钥。</p><p>然后发送回应服务器：随机数C（用服务器公钥进行加密）、编码改变通知（表示随后的信息都将用双方商定的加密方法和密钥发送）、客户端握手结束通知（表示客户端的握手阶段已经结束）。</p></li><li><p>服务器的最后回应</p><p>服务器收到客户端的随机数C之后，计算生成本次会话所用的”会话密钥”，向客户端回应：编码改变通知、服务器握手结束通知。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于HTTPS&quot;&gt;&lt;a href=&quot;#关于HTTPS&quot; class=&quot;headerlink&quot; title=&quot;关于HTTPS&quot;&gt;&lt;/a&gt;关于HTTPS&lt;/h3&gt;&lt;p&gt;  相信对于大多数开发人员，Https并不陌生，在http协议基础上套上一个加密解密的过程，就是Ht
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://offensiveyy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="https" scheme="http://offensiveyy.github.io/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>记我对Socket的误解</title>
    <link href="http://offensiveyy.github.io/2018/03/10/%E8%AE%B0%E6%88%91%E5%AF%B9Socket%E7%9A%84%E8%AF%AF%E8%A7%A3/"/>
    <id>http://offensiveyy.github.io/2018/03/10/记我对Socket的误解/</id>
    <published>2018-03-10T05:35:43.000Z</published>
    <updated>2018-03-10T07:24:00.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h2><p>记得刚开始学习Java网络编程的时候，接触的便是Socket，通过Socket和SocketServer建立一个TCP连接，然后获取网络流对象来传递数据。一个经典TCP连接建立过程：</p><p>客户端：</p><ul><li>创建一个 Socket 实例：构造函数向指定的远程主机和端口建立一个 TCP 连接；</li><li>通过套接字的 I/O 流与服务端通信；</li><li>使用 Socket 类的 close() 方法关闭连接。</li></ul><p>服务端:</p><ul><li>创建一个 ServerSocket 实例并指定本地端口，用来监听客户端在该端口发送的 TCP 连接请求；</li><li>重复执行：<ul><li>调用 ServerSocket 的 accept()方法以获取客户端连接，并通过其返回值创建一个 Socket 实例；</li><li>为返回的 Socket 实例开启新的线程，并使用返回的 Socket 实例的 I/O 流与客户端通信； 通信完成后，使用 Socket 类的 close()方法关闭该客户端的套接字连接。</li></ul></li></ul><p>在计算机网络课程中，了解到Socket的定义：</p><blockquote><p>套字节Socket = (IP地址 : 端口号)</p></blockquote><p>于是一直认为<del>Socket其实就是在封装了TCP协议的实现</del>。</p><p>PS：在Java的API中，Socket类确实就是封装TCP协议的实现。</p><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p>关于Socket的这个误解一直伴随着我到网络编程的课程上，上课使用的编程语言是C#。在C#中创建一个Socket对象如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.IP);</span><br></pre></td></tr></table></figure></p><p>该构造函数的参数含义：</p><p>第一参数定义了该Socket支持的协议族，AddressFamily.InterNetwork表示IPv4；</p><p>第二参数定义了该Socket的类型，SocketType.Stream表示TCP，此外还有Dgram(UDP)、Raw、Rdm、Seqpacket。</p><p>第三参数定义了该Socket支持协议，主要有IP、Tcp、Udp、Icmp、Ggp等。</p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.socket?view=netframework-4.7.1" target="_blank" rel="noopener">关于C#的Socket的更多说明</a></p><p>是不是和Java的Socket有大不同？到了这里，我才意识到我以前对Socket的理解太肤浅了。</p><h2 id="Socket究竟为何物？"><a href="#Socket究竟为何物？" class="headerlink" title="Socket究竟为何物？"></a>Socket究竟为何物？</h2><p>我们知道目前的TCP/IP网络模型，从上往下为：<br>应用层、运输层、网际层、网络接口层。</p><p>应用层包含众多应用协议，比如HTTP、SNMP、POP3等协议，这些协议的规定信息与数据报文在网络之中传输行为无关，只面向具体应用服务。</p><p>运输层就只有TCP与UDP协议，TCP协议通过握手机制、确认重传机制来提供可靠的连接，UDP则比较简单，因为提供不可靠的连接，所以不需要像TCP那样复杂。</p><p>网际层主要是提供网络中寻址的IP协议，还有用于数据包传输控制的多种路由协议、ICMP、IGMP等。</p><p>网络接口层包含了数据链路层和物理层，但在应用层软件开发中一般不需我们去关心。</p><p><strong>那么Socket和这些网络协议有什么关系呢？</strong></p><p>Socket主要和运输层和网际层这两层的协议有关，他们关系就像接口和实现类之间的关系。</p><p>Java中的Socket封装了TCP的实现，而在C#中Socket封装了多种协议的实现，通过构造函数的参数来选择Socket具体实现协议。所以Socket准确来说，应该是一个网络协议的编程接口，他不是为特定的协议设计。TCP、UDP协议都只是Socket的具体实现。</p><p>计算机网络课程教材上定义的Socket=(IP地址:端口号)，只有Socket的实现协议为运算层协议的时候才正确。当他的具体实现为ICMP(ping命令的数据包用的就是ICMP协议)时，更本不需要一个端口号。</p><p>参考:</p><ul><li><a href="https://www.zhihu.com/question/39541968" target="_blank" rel="noopener">TCP/IP、Http、Socket的区别? -知乎</a></li><li><a href="http://wiki.jikexueyuan.com/project/java-socket/socket-advanced.html" target="_blank" rel="noopener">Java TCP/IP Socket 编程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;误解&quot;&gt;&lt;a href=&quot;#误解&quot; class=&quot;headerlink&quot; title=&quot;误解&quot;&gt;&lt;/a&gt;误解&lt;/h2&gt;&lt;p&gt;记得刚开始学习Java网络编程的时候，接触的便是Socket，通过Socket和SocketServer建立一个TCP连接，然后获取网络流对
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://offensiveyy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Socket" scheme="http://offensiveyy.github.io/tags/Socket/"/>
    
      <category term="网络编程" scheme="http://offensiveyy.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android知识体系脑图</title>
    <link href="http://offensiveyy.github.io/2018/03/09/Android%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    <id>http://offensiveyy.github.io/2018/03/09/Android知识体系/</id>
    <published>2018-03-09T08:40:31.000Z</published>
    <updated>2018-03-09T14:19:28.530Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个靠自己摸爬滚打、自主探究的Android程序员，常常迷失在复杂的Android系统之中，面对日新月异的新技术，我们竭力追赶，但是在开发中，还是常常陷入一些莫名奇妙的bug之中，有时在网上搜搜到了解决方案，但是也有可能已经过时了，在新的系统版本中不适用。如果能有一个详细的学习体系结构，相信对系统地学习Android开发是有事半功倍的作用的。前几天，就在网上了解到了别人总结的Android知识体系，于是速速收藏，以便学习查阅。<br>    <img src="https://i.loli.net/2018/03/09/5aa26967de76b.jpeg" alt="Android知识架构脑图.jpeg"><br>    <a href="https://www.diycode.cc/topics/1172" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个靠自己摸爬滚打、自主探究的Android程序员，常常迷失在复杂的Android系统之中，面对日新月异的新技术，我们竭力追赶，但是在开发中，还是常常陷入一些莫名奇妙的bug之中，有时在网上搜搜到了解决方案，但是也有可能已经过时了，在新的系统版本中不适用。如果能有一个详
      
    
    </summary>
    
      <category term="Android" scheme="http://offensiveyy.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://offensiveyy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>关于</title>
    <link href="http://offensiveyy.github.io/2018/03/06/%E5%85%B3%E4%BA%8E/"/>
    <id>http://offensiveyy.github.io/2018/03/06/关于/</id>
    <published>2018-03-06T15:47:26.000Z</published>
    <updated>2018-03-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我是…"><a href="#我是…" class="headerlink" title="我是…"></a>我是…</h2><p>一个生性平和又勇于奋斗的偏佛系95后，一只Andoid程序猿，来自厂里，号称厂里的帅小伙。喜欢各种新奇的App，也喜欢喜欢研究与Android相关的各种黑科技。喜欢听音乐，口味偏向粤语歌和吉他曲。</p><h2 id="关于该博客"><a href="#关于该博客" class="headerlink" title="关于该博客"></a>关于该博客</h2><p>以前一直想搞一个个人博客，奈何博主在前端设计与技术这方面知识比较欠缺，所以一直跳票。但为了更好地记录自己的经历，在2018年3月初，在一个<a href="http://xuyonglin222.github.io" target="_blank" rel="noopener">前端老铁</a>的帮助下成功搭建了这个博客，在这鸣谢一下该老铁。该博客用Hexo+Github+Material主题进行搭建，用于个人的学习记录和日常分享。</p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><ol><li><a href="https://sm.ms" target="_blank" rel="noopener">SM.MS 图床</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;我是…&quot;&gt;&lt;a href=&quot;#我是…&quot; class=&quot;headerlink&quot; title=&quot;我是…&quot;&gt;&lt;/a&gt;我是…&lt;/h2&gt;&lt;p&gt;一个生性平和又勇于奋斗的偏佛系95后，一只Andoid程序猿，来自厂里，号称厂里的帅小伙。喜欢各种新奇的App，也喜欢喜欢研究与An
      
    
    </summary>
    
      <category term="日常" scheme="http://offensiveyy.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
</feed>
