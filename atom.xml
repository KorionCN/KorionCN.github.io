<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ksxy&#39;s Blog</title>
  
  <subtitle>个人技术博客 Android开发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.korion.cn/"/>
  <updated>2018-06-28T06:46:52.000Z</updated>
  <id>http://www.korion.cn/</id>
  
  <author>
    <name>空山新雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java线程池工作原理分析</title>
    <link href="http://www.korion.cn/2018/06/28/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://www.korion.cn/2018/06/28/Java线程池工作原理分析/</id>
    <published>2018-06-28T06:46:52.000Z</published>
    <updated>2018-06-28T06:46:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>  作为Android开发者，Java线程池在平常的开发中，比较少直接接触到，但如果查阅在SDK API和大多数第三方框架的源码，我们都能看到<br>Java线程池的身影，如果不能对Java线程池的原理有所了解，那么在使用线程池，或者分析框架源码时，容易变得飘飘然而不知所以然。</p><blockquote><p>PS: 以下代码分析基于JDK8</p></blockquote><h3 id="线程池实例化"><a href="#线程池实例化" class="headerlink" title="线程池实例化"></a>线程池实例化</h3><p>  首先，线程池的实现类是ThreadPoolExecutor，Java提供了两种实例化方式：</p><p>  <strong>1. 构造函数</strong></p><p>  ThreadPoolExecutor有四个构造方法,但最终都是通过调用参数最多的构造方法</p><pre><code>public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler)</code></pre><p>  <strong>corePoolSize</strong>: 线程池中核心线程数量</p><p>  <strong>maximumPoolSize</strong>: 线程池同时允许存在的最大线程数量</p><p>  内部的线程的创建策略：</p><ul><li>当线程池中的线程小于corePoolSize，创建线程的工作线程来处理该任务，不管是否有空闲的线程。</li><li>如果线程数达到corePoolSize, 优先将任务放入任务队列，等待核心线程的处理。</li><li>如果任务入队失败（队列已满）而线程数小于maximumPoolSize,则需要创建非核心线程来进程处理。</li><li><p>如果线程数达到maximumPoolSize,拒绝该任务。</p><p><strong>keepAliveTime\unit</strong>: 线程空闲时间\时间单位</p><p>如果非核心线程的空闲时间达到keepAliveTime，将会被终止。<br>如果设置了allowCoreThreadTimeout，则可以将该策略应用到核心线程上。</p><p><strong>workQueue</strong>: 存放执任务的队列</p><p>该参数可以有三种实现:</p></li><li><p>SynchronousQueue: 该策略直接将任务直接交给工作线程。如果当前没有空闲工作线程，创建新线程。</p></li><li>LinkedBlockingQueue: 如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE, 新的任务被放在队列上，不会有大于corePoolSize的线程被创建。</li><li><p>ArrayBlockingQueue: 此队列创建时必须指定大小,按前面描述的corePoolSize、maximumPoolSize、BlockingQueue处理逻辑处理。</p><p><strong>threadFactory</strong>: 创建线程的工厂，决定线程池创建线程的过程，线程池内部有默认实现</p><p><strong>handler</strong>: 拒绝任务时所用的策略。</p><p>在任务队列满时并且线程数达到maximumPoolSize时，需要采取拒绝策略处理该任务。Java提供了一下几种策略：</p></li><li><p>ThreadPoolExecutor#AbortPolicy：这个策略直接抛出RejectedExecutionException异常。</p></li><li>ThreadPoolExecutor#CallerRunsPolicy：这个策略将会使用Caller线程来执行这个任务，这是一种feedback策略，可以降低任务提交的速度。</li><li>ThreadPoolExecutor#DiscardPolicy：这个策略将会直接丢弃任务。</li><li><p>ThreadPoolExecutor#DiscardOldestPolicy: 这个策略将会把任务队列头部的任务丢弃，然后重新尝试执行新来的任务。</p><p>除了上述策略，可以通过实现RejectedExecutionHandler来实现自己的策略。</p><p><strong>2. 工厂方式</strong></p><p>通过Executors的静态方法创建：</p><p>Executors.newCachedThreadPool();        //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE<br>Executors.newSingleThreadExecutor();   //创建容量为1的缓冲池<br>Executors.newFixedThreadPool(int);    //创建固定容量大小的缓冲池</p><p>以上的几个方法具体实现比较简单，只是帮助我们封装好了一些参数，让开发者使用起来更方便。</p><p>不过，阿里的开发手册推荐我们使用第一种方法，</p><blockquote><p>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样<br>的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p> 说明：Executors 返回的线程池对象的弊端如下：</p><p> 1）FixedThreadPool 和 SingleThreadPool:<br>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</p><p> 2）CachedThreadPool 和 ScheduledThreadPool:<br>允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p></blockquote></li></ul><p>在实例化线程池后，我们可以使用execute(Runnable)来提交我们的任务，之后由线程池自动调度。</p><h3 id="工作原理分析"><a href="#工作原理分析" class="headerlink" title="工作原理分析"></a>工作原理分析</h3><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><p>   execute(Runnable)是我们提交任务的入口，具体实现了任务的执行策略，但是在了解execute(Runnable)之前需要了解线程池的状态。</p><p> 关于线程池的状态有以下几种:</p><ul><li>RUNNING: 接受新任务并处理排队的任务, 初始状态。</li><li>SHUTDOWN: 不接受新任务，但处理排队的任务。 RUNNING -&gt; SHUTDOWN: shutdown()</li><li>STOP: 不接受新任务，不处理排队的任务，并中断正在进行的任务。 (RUNNING or SHUTDOWN) -&gt; STOP: shutdownNow()</li><li>TIDYING: 所有任务已终止，工作线程为0，完成该状态后进入TERMINATED。</li><li><p>TERMINATED: TIDYING完成后。</p><p>//在JDK8中，用一个Int来保存线程池的状态和工作线程的数量，<br>//高4位为线程状态 低28位保存线程池状态<br>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));<br>private static final int COUNT_BITS = Integer.SIZE - 3;<br>private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1; //0000 1111 … 1111</p><p>// 线程池状态<br>private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;<br>private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;<br>private static final int STOP       =  1 &lt;&lt; COUNT_BITS;<br>private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;<br>private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</p><p>//获取线程池状态<br>private static int runStateOf(int ctl)     { return ctl &amp; ~CAPACITY; }<br>//获取线程池中线程数量<br>private static int workerCountOf(int ctl)  { return ctl &amp; CAPACITY; }<br>private static int ctlOf(int runState, int workCount) { return runState | workCount; }</p></li></ul><h4 id="其他重要的成员"><a href="#其他重要的成员" class="headerlink" title="其他重要的成员"></a>其他重要的成员</h4><pre><code>private final BlockingQueue&lt;Runnable&gt; workQueue;           //任务缓存队列，用来存放等待执行的任务private final ReentrantLock mainLock = new ReentrantLock();   //线程池的主要状态锁，对线程池状态（比如线程池大小runState等）的改变都要使用这个锁private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();  //用来存放Worker，每一个Worker对应一个线程private volatile long  keepAliveTime;    //线程存活时间private volatile boolean allowCoreThreadTimeOut;   //是否允许为核心线程设置存活时间private volatile int   corePoolSize;     //核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）private volatile int   maximumPoolSize;   //线程池最大能容忍的线程数private volatile RejectedExecutionHandler handler; //任务拒绝策略private volatile ThreadFactory threadFactory;   //线程工厂，用来创建线程private int largestPoolSize;   //用来记录线程池中曾经出现过的最大线程数private long completedTaskCount;   //用来记录已经执行完毕的任务个数</code></pre><h4 id="ThreadPoolExecutor-execute-Runnable"><a href="#ThreadPoolExecutor-execute-Runnable" class="headerlink" title="ThreadPoolExecutor#execute(Runnable)"></a>ThreadPoolExecutor#execute(Runnable)</h4><p>   了解了以上成员属性的作用后，回头看execute(Runnable):</p><pre><code>public void execute(Runnable command) {       if (command == null) //首先任务不能为null           throw new NullPointerException();       //在这里分三步走：       int c = ctl.get();       //1. 如果线程数 &lt; 核心线程，则直接调用addWorker。       //addWorker内部实例化一个Worker来处理该任务，Worker是ThreadPoolExecutor的内部类，       //具体实现后面讲解，这里假设Worker == Thread。       if (workerCountOf(c) &lt; corePoolSize) {           if (addWorker(command, true))  //添加成功返回               return;           c = ctl.get();       }       //2. 如果线程数达到核心线程数，尝试添加到workQueue，添加成功则返回       //对线程池的状态进行了判断，为了简化逻辑，我们当作线程池一直是RUNNING状态       if (isRunning(c) &amp;&amp; workQueue.offer(command)) {           int recheck = ctl.get();            //在这里再次对线程池的状态进行了判断，是为了处理shutdown()或shutdownNow()被其他线程调用时的情况           if (! isRunning(recheck) &amp;&amp; remove(command))               reject(command);           else if (workerCountOf(recheck) == 0)               addWorker(null, false);       }       //3. 添加到workQueue失败（队列已满)，调用addWorder()添加非核心线程（由第二个参数决定）       //添加失败,则调用拒绝策略。       else if (!addWorker(command, false))           reject(command);   }</code></pre><p>   从execute(Runnable)的实现，看出任务的调度策略。<br>   在这里，我们注意到了Worker这个内部类和addWorker().那么接下来查看他们的实现。<br>   addWorker中实例化了Worker。</p><h4 id="ThreadPoolExecutor-addWorker"><a href="#ThreadPoolExecutor-addWorker" class="headerlink" title="ThreadPoolExecutor#addWorker"></a>ThreadPoolExecutor#addWorker</h4><p>   addWorker有两个参数:</p><ol><li>firstTask: Worker执行的第一任务</li><li><p>core: ture -&gt; 创建Worker时，以corePoolSize为上限；</p><pre><code>  false -&gt; 以maximumPoolSize为上限。private boolean addWorker(Runnable firstTask, boolean core) { retry: for (;;) {     //省略对线程池状态的判断     for (;;) {         int wc = workerCountOf(c);         if (wc &gt;= CAPACITY ||             wc &gt;= (core ? corePoolSize : maximumPoolSize))  //线程数是否大于corePoolSize/maximumPoolSize, 如果是，则创建失败             return false;         if (compareAndIncrementWorkerCount(c))  //线程数+1             break retry;         c = ctl.get();  // Re-read ctl         if (runStateOf(c) != rs)             continue retry;     } } boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try {     w = new Worker(firstTask);  //实例化Worker     final Thread t = w.thread;     if (t != null) {         final ReentrantLock mainLock = this.mainLock;         mainLock.lock();         try {                 // 省略对线程池状态的判断                 workers.add(w);                 int s = workers.size();                 if (s &gt; largestPoolSize)                     largestPoolSize = s;    //记录线程池中最大线程数                 workerAdded = true;             }         } finally {             mainLock.unlock();         }         if (workerAdded) {  //创建成功，则执行Worker线程             t.start();             workerStarted = true;         }     } } finally {     if (! workerStarted)         addWorkerFailed(w);   //启动Worker失败，需要将Worker清理出workers } return workerStarted;}</code></pre><p>如果忽略对线程池状态的多次判断，addWorker中的代码相对简单。</p></li></ol><h4 id="ThreadPoolExecutor-Worker"><a href="#ThreadPoolExecutor-Worker" class="headerlink" title="ThreadPoolExecutor#Worker"></a>ThreadPoolExecutor#Worker</h4><pre><code>private final class Worker    extends AbstractQueuedSynchronizer    implements Runnable{        final Thread thread;  //该Worker持有的线程        Runnable firstTask;  //该Worker执行的第一个任务        volatile long completedTasks;  //该Worker完成的任务数        Worker(Runnable firstTask) {            setState(-1); // inhibit interrupts until runWorker            this.firstTask = firstTask;            //调用线程工厂创建线程实例            this.thread = getThreadFactory().newThread(this);        }        public void run() {            runWorker(this);        }        //省略了一部分代码    }</code></pre><p>   从上面的代码可以看出，Worker持有一个线程实例，而该线程实现上执行的是runWorker(Worker).</p><h4 id="ThreadPoolExecutor-runWorker"><a href="#ThreadPoolExecutor-runWorker" class="headerlink" title="ThreadPoolExecutor#runWorker"></a>ThreadPoolExecutor#runWorker</h4><pre><code>final void runWorker(Worker w) {        //以下省略部分代码，仅保留线程池调度任务的相关代码        Runnable task = w.firstTask;        w.firstTask = null;        boolean completedAbruptly = true;        try {            while (task != null || (task = getTask()) != null) {                //...                try {                    beforeExecute(wt, task);    //Java预留给我们的接口，默认为空实现                    Throwable thrown = null;                    try {                        task.run();  //我们提交的任务在这里被真正执行                    } catch  {                        //省略异常处理                    } finally {                        afterExecute(task, thrown);  //和beforeExecute类似                    }                } finally {                    task = null;                    w.completedTasks++;                }            }            completedAbruptly = false;        } finally {            processWorkerExit(w, completedAbruptly);  //getTask()返回null，workQueue中没有任务，进行清理工作        }}</code></pre><p> 可以看到，runWorker内部主体上一个循环，在该循环中，不停地通过getTask()取出workQueue中的任务去执行。直到<br> getTask返回null才退出这个循环，并且清理这个Worker。接下来查看getTask()</p><h4 id="ThreadPoolExecutor-getTask"><a href="#ThreadPoolExecutor-getTask" class="headerlink" title="ThreadPoolExecutor#getTask"></a>ThreadPoolExecutor#getTask</h4><pre><code>private Runnable getTask() {      boolean timedOut = false; // Did the last poll() time out?      for (;;) {          int c = ctl.get();          //这里省略对线程池状态判断一些代码          int wc = workerCountOf(c);          //这里可以看到允许线程池中线程超时的条件：          // 1. allowCoreThreadTimeOut = true          // 2. 线程数 &gt; corePoolSize          boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;          try {              //workQueue.poll(): 如果队列为空，阻塞keepAliveTime后，返回null              //workQueue.take(): 如果队列为空，将一直阻塞              Runnable r = timed ?                  workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :                  workQueue.take();                  if (r != null)                      return r;                  timedOut = true;              } catch (InterruptedException retry) {                  timedOut = false;              }      }}</code></pre><p> 到了这里，我们实际上已经了解，<strong>线程池调度任务的基本过程</strong>：</p><ol><li>提交一个任务后，线程池根据线程数和任务队列使用情况，来决定是否通过创建线程来执行，或者放入队列中，等待被调度；</li><li>线程池中的任务由Worker来执行，每个Worker对应着一个线程；</li><li>Worker在执行完当前的任务后，会继续尝试从workQueue中获取任务；</li><li>从队列中获取任务时，线程可能被队列阻塞，处于空闲状态；</li><li>如果是允许空闲超时，将在超时后，getTask返回null，从而退出runWorker中的循环，终止Worker所在的线程。</li></ol><h3 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h3><p>   在配置线程池的线程和队列时，一般根据任务的类型来配置：</p><ol><li><p>CPU密集型任务: 任务内容侧重于计算, 参考值可以设为CPU核心数+1，减少线程调度。</p></li><li><p>IO密集型任务：任务内存侧重IO，比如网络请求、文件读写，参考值可以设置为2*CPU核心数，避免IO阻塞导致的性能下降。</p></li></ol><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>   在阅读线程池的源码前，一直存在一种抗拒的心理，因为看源码并不是一件轻松的事，大多数时候，我们很容易迷失在源码的很多细节中，<br>   比如，我一开始也被线程池中，各种状态的判断和对过程的同步锁弄昏了，来来回回看了很多遍，又查阅了其他资料查。而通过这次学习，<br>   我意识到，在查看源代码时应该懂得适当忽略一些细节，先弄情况整体上的架构，理清思路，才不容易迷失。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://www.jianshu.com/p/896b8e18501b" target="_blank" rel="noopener">Java线程池分析及策略优化</a></li><li><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">Java并发编程：线程池的使用</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  作为Android开发者，Java线程池在平常的开发中，比较少直接接触到，但如果查阅在SDK API和大多数第三方框架的源码，我们都能看到&lt;br&gt;Java线程池的身影，如果不能对Java线程池的原理有所了解，那么在使用线程池，或者分析框架源码时，容易变得飘飘然而不知所以
      
    
    </summary>
    
      <category term="Java" scheme="http://www.korion.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.korion.cn/tags/Java/"/>
    
      <category term="线程池" scheme="http://www.korion.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Linux使用技巧:文件上下传</title>
    <link href="http://www.korion.cn/2018/06/16/Linux%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%B8%8B%E4%BC%A0/"/>
    <id>http://www.korion.cn/2018/06/16/Linux使用技巧-文件上下传/</id>
    <published>2018-06-16T12:40:19.000Z</published>
    <updated>2018-06-16T12:40:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在使用云主机时，文件上传下载的常见的场景。本文主要介绍几个比较实用文件上传下载工具。</p></blockquote><h3 id="Sftp"><a href="#Sftp" class="headerlink" title="Sftp"></a>Sftp</h3><p>   Sftp(Secure File Transfer Protocol, 安全文件传送协议), 相当于在在ssh的基础上实现了ftp。<br>sftp的服务端也是依托于sshd守护进程，作为sshd服务的一部分，所以只要远程主机上支持ssh服务就可以使用<br>sftp传输文件，使用上和ssh、ftp差不多。</p><p> <strong>1. 连接</strong></p><blockquote><p>sftp 用户名@主机地址  # 和ssh一样</p></blockquote><p> <strong>2. 传输</strong></p><p>   登录后,sftp提供两套命令分别操作本地文件和远程主机文件。比如，lpwd和pwd, lls和ls, lmkdir和mkdir.</p><p>   输入help可以查看说明.</p><p>   <strong>上传&amp;下载:</strong></p><blockquote><p>上传: put filename(本地主机) [path(远程主机)] #默认远程主机当前目录</p><p>下载: get filename(远程主机) [path(本地主机)] #默认本地主机当前目录</p></blockquote><h3 id="Lrzsz"><a href="#Lrzsz" class="headerlink" title="Lrzsz"></a>Lrzsz</h3><blockquote><p>lrzsz是一款在linux里可代替ftp上传和下载的程序。</p></blockquote><p> 个人推荐用这个，太方便了。</p><p><strong>1. 安装</strong></p><blockquote><p>#yum install -y lrzsz   #CentOS</p><p>#apt install -y lrzsz   #Debian、Ubuntu</p></blockquote><p><strong>2. 使用</strong></p><blockquote><p>上传: rz   # 运行这个命令后，会弹出一个文件选择窗口. 不支持窗口化的终端用不了</p><p>下载: sz 文件 #运行这个命令后，会弹出一个窗口，选择下载路径</p></blockquote><h3 id="WinScp"><a href="#WinScp" class="headerlink" title="WinScp"></a>WinScp</h3><p>  如果你不习惯使用命令工具，那么可以使用<a href="https://winscp.net/eng/docs/lang:chs" target="_blank" rel="noopener">WinScp</a>。</p><p>  图形化操作就不多说明了，参考软件的使用引导即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在使用云主机时，文件上传下载的常见的场景。本文主要介绍几个比较实用文件上传下载工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Sftp&quot;&gt;&lt;a href=&quot;#Sftp&quot; class=&quot;headerlink&quot; title=&quot;Sftp&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.korion.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.korion.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux使用技巧:ssh密钥登录</title>
    <link href="http://www.korion.cn/2018/06/14/Linux-ssh%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95/"/>
    <id>http://www.korion.cn/2018/06/14/Linux-ssh密钥登录/</id>
    <published>2018-06-14T13:17:12.000Z</published>
    <updated>2018-06-14T13:17:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  关于Linux使用技巧的一些总结。</p></blockquote><h3 id="ssh密钥登录"><a href="#ssh密钥登录" class="headerlink" title="ssh密钥登录"></a>ssh密钥登录</h3><p>   使用ssh连接主机时，每次都需要输入用户名，虽然不是很麻烦，但是对于密码健忘的人来说，常常需要去控制面板<br>查看密码。。。幸好ssh支持更安全、方便的密钥登录。</p><h3 id="关于ssh的疑惑"><a href="#关于ssh的疑惑" class="headerlink" title="关于ssh的疑惑"></a>关于ssh的疑惑</h3><p>   其实，在此之前，我已经使用ssh密钥登录很多次，但是对ssh存在一些疑惑，一直没有弄明白。</p><ul><li>${HOME}/.ssh的几个文件的作用;</li><li>一台本地主机如何保存多台远程主机的密钥?</li><li>密钥对是保存在本地主机还是远程主机？</li></ul><p><strong>1. .ssh/known_hosts</strong></p><p>   我们知道ssh提供了两种身份认证方式，一种是用户名+密码，一种是非对称加密密钥认证。ssh在首次连接一台主<br>机时，ssh服务端会发送一个非对称加密的公钥给客户端，用于之后传输数据的加密，这是ssh自动产生的密钥对<br>（我称为连接密钥）。ssh会将这个密钥对的公钥保存在本地用户目录下的.ssh/known_hosts中.</p><blockquote><p>  格式: 主机域名/IP 密钥算法类型 公钥</p></blockquote><p>   所以，我们的本地主机就是在这个文件中，保存了多台远程主机的连接密钥的。</p><p><strong>2. .ssh/id_rsa和id_rsa.pub</strong></p><p>   与上面的连接密钥不同，我们使用的ssh登录密钥需要自己生成，生成后默认会在.ssh目录下产生id_rsa和<br>id_rsa.pub这两文件，id_rsa保存了私钥，而id_rsa.pub保存了公钥。使用时，我们需要把公钥放到远程主机上。<br>但是直接复制上去，发现连接时ssh提示使用的密钥在远程主机上未注册。</p><p><strong>3. .ssh/authorized_keys</strong></p><p>   原来不能把公钥直接复制上去，远程主机上有一个.ssh/authorized_keys文件，只有这个文件中的密钥才能被<br>允许认证。</p><p>   <strong>这里弄清楚这几个文件的作用，有助于管理我们的密钥。</strong></p><h3 id="登录密钥生成与部署"><a href="#登录密钥生成与部署" class="headerlink" title="登录密钥生成与部署"></a>登录密钥生成与部署</h3><p>   这里主要使用ssh-keygen 和 ssh-copy-id这个两个命令。</p><p><strong>1. 生成密钥</strong></p><blockquote><p> ssh-keygen -t rsa -C “comment”</p></blockquote><p>-t: 选择非对称加密算法类型，这里使用的是rsa</p><p>-b: 指定密钥长度，默认2048位</p><p>-C: 用于添加一个标识，生成密钥后，会在公钥结尾加上，方便对密钥进行区分，比如邮箱</p><p>执行上面的命令后，会要求你填写密钥文件名和生成密钥时的口令，可以直接回车。<br>之后，就会在${HOME}/.ssh目录下生成ida_rsa 和ida_rsa.pub这两个文件.</p><p><strong>2. 部署密钥</strong></p><blockquote><p>ssh-copy-id 用户名@远程主机名/IP</p></blockquote><p>然后输入对应用户名密码，就可以将id_rsa.pub添加到远程主机的authorized_keys文件。</p><p>部署完毕，就可以用密钥验证登录了。</p><p><strong>最后</strong>, 无论密钥对在哪里生成，都要保管好私钥，同一个公钥可以部署到多台远程主机上，但是私钥不能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;  关于Linux使用技巧的一些总结。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ssh密钥登录&quot;&gt;&lt;a href=&quot;#ssh密钥登录&quot; class=&quot;headerlink&quot; title=&quot;ssh密钥登录&quot;&gt;&lt;/a&gt;ssh密钥登录&lt;/h3
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.korion.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.korion.cn/tags/Linux/"/>
    
      <category term="ssh" scheme="http://www.korion.cn/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Linux单用户模式拯救密码</title>
    <link href="http://www.korion.cn/2018/06/05/Linux%E5%8D%95%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E6%8B%AF%E6%95%91%E5%AF%86%E7%A0%81/"/>
    <id>http://www.korion.cn/2018/06/05/Linux单用户模式拯救密码/</id>
    <published>2018-06-04T16:01:51.000Z</published>
    <updated>2018-06-04T16:01:51.000Z</updated>
    
    <content type="html"><![CDATA[<p> 今天实验课上，尝试使用Hadoop搭建分布式的计算环境，实验通过三台虚拟机进行，因为我的电脑只有8G的内存，启动三台虚拟机内存可能要吃紧，所以打算在我的Deepin Linux系统下完成，一来主机本身就是Linux系统，二来只要在启动两个虚拟机就可以了。</p><p>当我启动Linux系统后，发现自己怎么输入密码都不对，幸好Linux都是支持在单用户模式下更改密码的。</p><h3 id="单用户模式"><a href="#单用户模式" class="headerlink" title="单用户模式"></a>单用户模式</h3><blockquote><p>单用户模式（Single user mode），是在类Unix系统上工作时的一种拥有超级用户权限的模式。通常在引导菜单给予1或S参数能进入这个模式。这个模式只在面对主机实体时才有机会通过引导菜单进入，也因此确保超级权限授予的对象是能接触到主机的超级用户。此操作通常用于维护硬盘分区或更改超级用户密码等需在磁盘挂载前操作的维护。   –Wiki百科</p></blockquote><h3 id="进入单用户模式"><a href="#进入单用户模式" class="headerlink" title="进入单用户模式"></a>进入单用户模式</h3><p>在这里先声明一下，进入单用户模式需要改动GRUB启动项的参数，不同的Linux 发行版本可能不同.博主一直用的桌面Linux是<a href="https://www.deepin.org/" target="_blank" rel="noopener">Deepin</a>,所以以下内容针对Deepin(<del>Ubuntu系列通用</del>)。</p><ol><li>在GRUB启动项中，选择Deepin的启动</li><li>摁E键，可以进入该启动项的编辑模式</li><li>将启动参数”ro  splash quiet” 改成 “rw single init=/bin/bash”</li><li>摁F10或者Ctrl+X，启动引导，稍等后即可进入单用户模式</li></ol><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p>单用户模式下，具有最高的权限，可以修改任何用户的密码，包括root。<br>使用命令</p><blockquote><p>passwd {用户名}</p></blockquote><p>然后输入两次密码即可。<br>最后，重启系统。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 今天实验课上，尝试使用Hadoop搭建分布式的计算环境，实验通过三台虚拟机进行，因为我的电脑只有8G的内存，启动三台虚拟机内存可能要吃紧，所以打算在我的Deepin Linux系统下完成，一来主机本身就是Linux系统，二来只要在启动两个虚拟机就可以了。&lt;/p&gt;
&lt;p&gt;当
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.korion.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.korion.cn/tags/Linux/"/>
    
      <category term="单用户模式" scheme="http://www.korion.cn/tags/%E5%8D%95%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android DrawLayout状态栏适配</title>
    <link href="http://www.korion.cn/2018/05/13/Android%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F%E9%80%82%E9%85%8D/"/>
    <id>http://www.korion.cn/2018/05/13/Android沉浸式状态栏适配/</id>
    <published>2018-05-13T13:08:24.000Z</published>
    <updated>2018-05-13T13:08:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>  之前，使用DrawerLayout写了个带侧栏菜单的App，在侧栏Open时，发现状态栏是</p><p>  <img style="width:250px; " src="https://i.loli.net/2018/05/17/5afd76f97ea6f.png" alt="device-2018-05-17-203307.png" title="device-2018-05-17-203307.png"></p><p>  但是我想要的效果应该是这样样子的，</p><p>  <img style="width:250px; " src="https://i.loli.net/2018/05/17/5afd76f981144.png" alt="device-2018-05-17-203419.png" title="device-2018-05-17-203419.png"></p><p>  emmm,类似的问题网上已经有很多相关的资料，搜索Android沉浸式状态栏适配即可，Github上也有不少的轮子。<br>  这里，我使用的是<a href="https://github.com/Zackratos/UltimateBar" target="_blank" rel="noopener">UltimateBar</a>，效果还挺不错的。问题是解决了，但是作为一只有着成为高级Android工程师的程序猿，怎么能不去探究其中的为什么呢?</p><p>  在查看了别人相关的文章后，我发现多数都是</p><ol><li><p>Android 4.4及之前</p><pre><code> //在Activity的根布局文件中添加android:fitsSystemWindows=&quot;true&quot; //然后设置以下Window标志 getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);</code></pre></li><li><p>Android 5.0 及之后</p><pre><code> if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {     Window window = getWindow();     window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);     window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN             | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);     window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);     window.setStatusBarColor(Color.TRANSPARENT); }</code></pre><p>然后，加上几张效果图。</p><p>那我就好奇了，添加了以上的代码后，究竟发生了什么?</p></li></ol><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>  所以，接下来我就开始研究了这么些代码对UI产生的影响，查看上面API的源码，发现其实就是设置一些标志位，所以看代码根本看不出了个所以然。于是我想到了另一种思路，因为Android中的视图是由一颗View树构成的，而Android Studio恰好可以查看一个视图下的View树。可以使用<a href="https://developer.android.com/studio/profile/hierarchy-viewer" target="_blank" rel="noopener">HierarchyViewer</a>或<a href="https://developer.android.com/studio/debug/layout-inspector" target="_blank" rel="noopener">Layout Inspector</a>查看。</p><p>  PS: HierarchyViewer官方已经不再支持，最高支持的JDK8, 一开始我的JDK是1.9版本，一直运行不起来还不报错。。。所以推荐使用LayoutInspector，而且真机上HierarchyViewer比不能获取到View的层次结构。</p><h4 id="关于Android-View层次结构"><a href="#关于Android-View层次结构" class="headerlink" title="关于Android View层次结构"></a>关于Android View层次结构</h4><p>  我们知道Android的每个视图都有一个称为DecorView的根View, 这个View其实就是一个FrameLayout，我们在xml文件中定义的视图和系统的一些视图都是DecorView的子View。</p><p>  首先，我们看看在默认的标志的情况下的视图结构，</p><p>  <img src="https://i.loli.net/2018/05/18/5afe7328f2c9b.png" alt="TIM图片20180518143022.png" title="TIM图片20180518143022.png"></p><p>  可以看到，状态栏和导航栏下分别有一个与其大小相当View（statusBarBackground和navigationBarBackground），做填充和背景。</p><h4 id="FLAG-TRANSLUCENT-STATUS"><a href="#FLAG-TRANSLUCENT-STATUS" class="headerlink" title="FLAG_TRANSLUCENT_STATUS"></a>FLAG_TRANSLUCENT_STATUS</h4><p>接下来我们设置<a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams#flag_translucent_status" target="_blank" rel="noopener">FLAG_TRANSLUCENT_STATUS</a>，再观察视图结构的变化。</p><p>方法1:     </p><pre><code>window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)  //kotlin</code></pre><p>方法2: 在主题中覆盖</p><pre><code>&lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;</code></pre><p>下面效果图，可以看到ToolBar延伸到了状态下面，同时发现视图结构的中并没有statusBarBackground。</p><p><img style="width:250px; " src="https://i.loli.net/2018/05/18/5afe78e431ad2.png" alt="device-2018-05-18-144143.png" title="device-2018-05-18-144143.png"></p><p><img style="width:250px; " src="https://i.loli.net/2018/05/18/5afe796f781b4.png" alt="device-2018-05-18-145330.png" title="device-2018-05-18-145330.png"></p><p><img style="width:250px; " src="https://i.loli.net/2018/05/18/5afe75f391572.png" alt="TIM图片20180518144039.png" title="TIM图片20180518144039.png"></p><p>至此，我们可以看到了Window的标志位对视图结构的影响，<strong>FLAG_TRANSLUCENT_STATUS取消了statusBarBackground</strong>。</p><h4 id="fitsSystemWindows"><a href="#fitsSystemWindows" class="headerlink" title="fitsSystemWindows"></a>fitsSystemWindows</h4><p>  虽然设置FLAG_TRANSLUCENT_STATUS后, 侧栏open或close，状态栏都是透明的，但是效果不对，不能然视图延伸到状态栏下面。</p><p>  于是在xml中，给右侧内容视图添加android:fitsSystemWindows=”true”。<a href="https://developer.android.com/reference/android/view/View.html#setFitsSystemWindows(boolean" target="_blank" rel="noopener">fitsSystemWindows</a>的作用: <strong>当它为true时，当前View在布局时，需要检查是否被状态栏覆盖，如果是，需要给该View添加一个高度为状态栏高度的paddingTop</strong>。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v4.widget.DrawerLayout   &lt;!--省略此处属性--&gt;    &gt;    &lt;!--主界面--&gt;    &lt;LinearLayout        android:id=&quot;@+id/root_layout&quot;        android:orientation=&quot;vertical&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:fitsSystemWindows=&quot;true&quot;    &lt;!--注意这里--&gt;        &gt;        &lt;include layout=&quot;@layout/center_title_toolbar&quot;/&gt;        &lt;FrameLayout            android:id=&quot;@+id/content_frame&quot;            &lt;!--省略此处属性--&gt;            &gt;        &lt;/FrameLayout&gt;    &lt;/LinearLayout&gt;    &lt;!--侧拉栏--&gt;    &lt;com.ksxy.messagesender.ui.customview.SidebarView        &lt;!--省略此处属性--&gt;        android:layout_gravity=&quot;start&quot;        /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt;</code></pre><p>效果:</p><p><img style="width:250px; " src="https://i.loli.net/2018/05/18/5afe7e7d4af53.png" alt="device-2018-05-18-151747.png" title="device-2018-05-18-151747.png"></p><p><img style="width:250px; " src="https://i.loli.net/2018/05/18/5afe7e7ee27b7.png" alt="device-2018-05-18-151755.png" title="device-2018-05-18-151755.png"></p><p><img style="width:250px; " src="https://i.loli.net/2018/05/18/5afe7f086eb75.png" alt="TIM图片20180518152126.png" title="TIM图片20180518152126.png"></p><p>emmm, 效果已经很久近我们想要的了，在侧栏close的情况下，状态栏由于没有任何背景颜色，所以呈现默认的底色，在不同系统上可能不同。</p><h4 id="状态栏颜色"><a href="#状态栏颜色" class="headerlink" title="状态栏颜色"></a>状态栏颜色</h4><p>  实际上，在Android API 21之后，Google提供了<a href="https://developer.android.com/reference/android/view/Window#setstatusbarcolor" target="_blank" rel="noopener">Window#setstatusbarcolor()</a>这个方法给我们改变状态的颜色，但是在本案例中，使用Window#setstatusbarcolor达不到我们想要的效果, 因为这个API是通过改变statusBarBackground这个View的背景颜色生效，但是我们为了侧栏的内容够延伸到状态栏下，设置了FLAG_TRANSLUCENT_STATUS，即没有statusBarBackground这个View所以达不到文章开头提到的效果。</p><p>  那么，我们通过什么方法解决问题呢?请看代码，</p><pre><code>  //1. 设置透明状态栏   window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)  //2. 在DecorView下添加一个大小为StatusBar大小的View，颜色为主题中定义的R.color.colorPrimary   val statusBarHeightId = resources.getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;)        val height = resources.getDimensionPixelSize(statusBarHeightId)  //获取StatusBar的高度   val v = View(baseContext)   val p = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, height)   p.gravity = Gravity.TOP   v.layoutParams = p   v.background = ColorDrawable(resources.getColor(R.color.colorPrimary))  //设置颜色   (window.decorView as ViewGroup).addView(v, 0)</code></pre><p>  效果:</p><p>  <img style="width:250px; " src="https://i.loli.net/2018/05/18/5afe86380b1c0.png" alt="TIM图片20180518155129.png" title="TIM图片20180518155129.png"></p><p> <img style="width:250px; " src="https://i.loli.net/2018/05/18/5afe8638228e2.png" alt="TIM图片20180518155152.png" title="TIM图片20180518155152.png"></p><p> <img style="width:250px; " src="https://i.loli.net/2018/05/18/5afe863826ad0.png" alt="TIM图片20180518155005.png" title="TIM图片20180518155005.png"></p><p> 在视图结构中可以看的我们添加的的那个View, emmm,好像有点不对，为啥他与navigationBarBackground同一级，在侧栏Open时为啥没有将侧栏挤下来?</p><p> 事情是这样的，DecorView是一个FrameLayout，我们添加的View是被图中的LinearLayout覆盖在下面，因为我们主布局中设置了fitsSystemWindows，空白的地方刚好能够”看到”底下的View，所以侧栏Open时并不会被”挤”下来。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好了，以上就的关于DrawerLayout的状态栏适配过程，可以看到实际对Drawlayout的侧栏的适配还是比较麻烦的。如果不需要将我们的布局内容延伸到状态栏下，实际上只需要设配我们状态栏色，那就比较简单。直接使用Window#setstatusbarcolor()就可以 了。上面截图都我在Android 6.0 上截的，但是实际上FLAG_TRANSLUCENT_STATUS在API 19上就已经有了，所以最低可以兼容到Android 4.4.</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>  上面介绍到的也就FLAG_TRANSLUCENT_STATUS和fitsSystemWindows，内容有点薄。实际上Window好很多起他的标志位，除了Window外，DecorView也可以设置一下标志位来影响视图。下面补充对几个想过的Flag的说明。</p><h4 id="window-addFlags"><a href="#window-addFlags" class="headerlink" title="window#addFlags"></a>window#addFlags</h4><ol><li><p>WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION</p><p>和FLAG_TRANSLUCENT_STATUS差不多，区别去掉的是底部的navigationBarBackground(View)，使内容延伸到导航栏下。</p></li><li><p>WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS</p><p>和Window#setstatusbarcolor()配合使用，FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS指示系统栏以透明背景绘制，并且此窗口中的相应区域将填充指定的颜色。</p></li></ol><h4 id="View-setSystemUiVisibility"><a href="#View-setSystemUiVisibility" class="headerlink" title="View#setSystemUiVisibility"></a>View#setSystemUiVisibility</h4><ol><li><p>View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</p><p>使布局内容延伸到状态栏。该标志不会”丢掉”statusBarBackground(View), 所以可以使用Window#setstatusbarcolor()自定义状态颜色，不过党颜色为全透明时，statusBarBackground(View)会被”丢弃”。这应该是一种优化吧。</p></li><li><p>View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</p><p>使布局内容延伸到导航栏。和SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN一样，可以用Window#setNavigationBarColor()自定义颜色，除非为全透明，不然不会”丢弃”navigationBarBackground(View)</p></li><li><p>View.SYSTEM_UI_FLAG_LAYOUT_STABLE</p><p>保持View Layout不变，隐藏状态栏或者导航栏后，布局不会延伸到状态栏或者导航栏。和上面两个同时设置时，该项无效。</p></li><li><p>View.SYSTEM_UI_FLAG_HIDE_NAVIGATION</p><p>隐藏底部的导航栏。会”丢弃”navigationBarBackground.但可以恢复</p></li><li><p>View.SYSTEM_UI_FLAG_FULLSCREEN</p><p>隐藏顶部状态栏。等同于(WindowManager.LayoutParams.FLAG_FULLSCREEN)，但可以恢复statusBarBackground。</p></li><li><p>View.SYSTEM_UI_FLAG_IMMERSIVE</p><p>在没有设置该标志位时，然后交互动作都退出View.SYSTEM_UI_FLAG_HIDE_NAVIGATION 状态。在设置后, 从底部向上滑，退出View.SYSTEM_UI_FLAG_HIDE_NAVIGATION</p></li><li><p>View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY</p><p>设置该标志位时，View.SYSTEM_UI_FLAG_IMMERSIVE同时也会被设置，这边标志位的作用在于临时退出View.SYSTEM_UI_FLAG_FULLSCREEN或View.SYSTEM_UI_FLAG_HIDE_NAVIGATION，退出一会后恢复隐藏的状态。</p></li></ol><p>  更多可以查看官方文档:<br>  <a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams" target="_blank" rel="noopener">WindowManager.LayoutParams</a>和<a href="https://developer.android.com/reference/android/view/View" target="_blank" rel="noopener">View#setSystemUiVisibility(int)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;  之前，使用DrawerLayout写了个带侧栏菜单的App，在侧栏Open时，发现状态栏是&lt;/p&gt;
&lt;p&gt;  &lt;img style=&quot;w
      
    
    </summary>
    
      <category term="Android" scheme="http://www.korion.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.korion.cn/tags/Android/"/>
    
      <category term="开发笔记" scheme="http://www.korion.cn/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="StatusBar" scheme="http://www.korion.cn/tags/StatusBar/"/>
    
      <category term="DrawLayout" scheme="http://www.korion.cn/tags/DrawLayout/"/>
    
  </entry>
  
  <entry>
    <title>Android短信发送与监听读取</title>
    <link href="http://www.korion.cn/2018/05/13/Android%E7%9F%AD%E4%BF%A1%E5%8F%91%E9%80%81%E4%B8%8E%E7%9B%91%E5%90%AC%E8%AF%BB%E5%8F%96/"/>
    <id>http://www.korion.cn/2018/05/13/Android短信发送与监听读取/</id>
    <published>2018-05-12T16:51:19.000Z</published>
    <updated>2018-05-12T16:51:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>  最近的开发中，需要调用系统API来进行短信发送，当接受到短信时需要将短信内容读取出来。根据官方的相关文档成功实现了，在这做一个简要的记录。</p><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><ul><li>短信发送</li><li>短信接收监听</li><li>短信读取</li></ul><h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><ul><li>SmsManager</li><li>Telephony</li><li>ContentResolver</li><li>BroadcastReceiver</li></ul><h3 id="Go"><a href="#Go" class="headerlink" title="Go!"></a>Go!</h3><h4 id="短信发送"><a href="#短信发送" class="headerlink" title="短信发送"></a>短信发送</h4><p>  从网上了解到发送短信可以使用SmsManager这个系统服务，于是根据官方文档折腾了一番。</p><ol><li><p>配置权限</p><pre><code> &lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot; /\&gt;</code></pre><ul><li>Android 6.0 以上需要动态申请该权限</li></ul></li><li><p>smsManager.sendTextMessage() 参数</p><p>该方法一共有5个参数:</p><ul><li>destinationAddress: String, 短信接收方的号码</li><li>scAddress: String, 短信发送方的号码，为null，使用当前默认的SMSC</li><li>text: String, 短信内容</li><li>sentIntent: PendingIntent, 短信发送后，执行这个PendingIntent。在发送短信前注册一个广播接收器，利用这个参数，在短信发送后通知该广播接收器，可以实现短信发送结果的监听。</li><li>deliveryIntent: PendingIntent, 这个和sentIntent差不多，区别在于，这个是在短信被接收后执行。</li></ul></li></ol><ol><li><p>代码</p><pre><code> private fun sendMessage(number: String, text: String){       if(ActivityCompat.checkSelfPermission(activity!!,Manifest.permission.SEND_SM)           == PackageManager.PERMISSION_GRANTED){              val smsManager = SmsManager.getDefault()   //获取SmsManager实例           val msgList = smsManager.divideMessage(text)  //如果短信内容太长，需要分割成多条发送           for (item in msgList){               val sentIntent = initMessageIntent(SEND_SMS_ACTION, null)               smsManager.sendTextMessage(number, null, item, sentIntent, null)  //逐条发送短信           }       }else{           ToastUtils.showShort(&quot;没有发送短信的权限!&quot;)       }   } //记得在生命周期回调函数中，注册和注销这个BroadcastReceiver private val msgSentResultListener = object : BroadcastReceiver(){       override fun onReceive(context: Context?, intent: Intent?) {       if (SEND_SMS_ACTION.equals(intent?.action)){           if(resultCode == Activity.RESULT_OK){               ToastUtils.showShort(&quot;短信发送成功&quot;)           }else{               ToastUtils.showShort(&quot;短信发送失败&quot;)           }         }      } }</code></pre></li></ol><h4 id="短信接收监听"><a href="#短信接收监听" class="headerlink" title="短信接收监听"></a>短信接收监听</h4><p>  短信的接收监听可以通过两种方式来实现: 设置广播接收器、设置短信观察者</p><ol><li><p>默认短信App</p><p>在Android 4.4之后，Google加强了对短信内容的管理，系统中只有默认短信App对短信内容具有全部权限，其他短信相关的App只能读取，不能做修改。默认短信App可以在系统中的默认应用设置。</p><p>默认短信APP可以接收Action为SMS_DELIVER_ACTION、WAP_PUSH_DELIVER_ACTION、ACTION_SENDTO、ACTION_RESPOND_VIA_MESSAGE的Intent，其余的短信App只能接收SMS_RECEIVED_ACTION。</p></li><li><p>广播接收器方式</p><p>当接收到短信时，系统会发出Action为SMS_RECEIVED_ACTION的广播，所以我们只需设置接收器接收者广播就可以了。</p><pre><code> &lt;!--所需权限, 6.0以上需要动态申请--!&gt; &lt;uses-permission android:name=&quot;android.permission.RECEIVE_MMS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot; /&gt; private val msgReceiveListener = object : BroadcastReceiver() {     override fun onReceive(context: Context?, intent: Intent?) {         Log.d(TAG, &quot;短信来了&quot;)         ......    //短信读取     } } //Fragment中， //在生命周期中注册或者静态注册都行  activity?.registerReceiver(msgReceiveListener, IntentFilter(Telephony.Sms.Intents.SMS_RECEIVED_ACTION)) //动态注册记得销毁  activity?.unregisterReceiver(msgReceiveListener)</code></pre></li><li><p>观察者方式</p><p>观察者方式是通过ContentResolver#registerContentObserver()想Sms ContentProvider注册观察者实现的。</p><pre><code> //将smsObserver注册到Sms的ContentProvider //第二个参数为notifyForDescendants, 为true，表示同时观察Uri的扩展Uri //Telephony.Sms.CONTENT_URI = content://sms/ //收件箱：content://sms/inbox //发件箱：content://sms/sent //草稿箱：content://sms/draft contentResolver?.registerContentObserver(Telephony.Sms.CONTENT_URI, false, smsObserver) public val smsObserver = object: ContentObserver(Handler(Looper.getMainLooper())){     override fun onChange(selfChange: Boolean) {         super.onChange(selfChange)         Log.d(TAG, &quot;短信内容发生变化!&quot;)     } } contentResolver?.unregisterContentObserver(smsObserver)</code></pre><p>以上两种方法都可以实现短信的监听，而在我选择使用广播的方式，因为注册观察者的方式在除了接收短信外，发送短信、删除短信，都会触发，在实现对短信接收的监听时，需要去判断情况，反而比较麻烦。</p></li></ol><h4 id="短信读取"><a href="#短信读取" class="headerlink" title="短信读取"></a>短信读取</h4><p>  通过ContentResolver查询Telephony.Sms.CONTENT_URI。</p><ol><li><p>在查询数据库之前需要了解其表结构:</p><p>sms主要结构：</p><ul><li>_id：          短信序号，如100</li><li>thread_id：对话的序号，如100，与同一个手机号互发的短信，其序号是相同的</li><li>address：  发件人地址，即手机号，如+86138138000</li><li>person：   发件人，如果发件人在通讯录中则为具体姓名，陌生人为null</li><li>date：       日期，long型，如1346988516，可以对日期显示格式进行设置</li><li>protocol： 协议0SMS_RPOTO短信，1MMS_PROTO彩信</li><li>read：      是否阅读0未读，1已读</li><li>status：    短信状态-1接收，0complete,64pending,128failed</li><li>type：       短信类型1是接收到的，2是已发出</li><li>body：      短信具体内容</li><li>service_center：短信服务中心号码编号</li></ul></li></ol><ol><li><p>代码</p><pre><code> &lt;!--所需权限, 6.0以上需要动态申请--!&gt; &lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot; /&gt; private val msgReceiveListener = object : BroadcastReceiver() {         override fun onReceive(context: Context?, intent: Intent?) {             Log.d(TAG, &quot;短信来了&quot;)             val cursor = activity?.contentResolver!!.query(Telephony.Sms.CONTENT_URI,                     null,                            Telephony.Sms.ADDRESS+&quot; = ? AND &quot;+Telephony.Sms.TYPE+&quot; = ?&quot;,   //查询某个号码，类型为接收的短信                     arrayOf(mNumber, &quot;1&quot;),                     Telephony.Sms.DATE +&quot; DESC LIMIT 1&quot;  //按时间降序查询1条记录                     )             if (cursor != null){                 while (cursor.moveToNext()){                     Log.d(TAG, cursor.getString(cursor.getColumnIndex(Telephony.Sms.ADDRESS)))                     Log.d(TAG, cursor.getString(cursor.getColumnIndex(Telephony.Sms.DATE)))                     Log.d(TAG, cursor.getString(cursor.getColumnIndex(Telephony.Sms.BODY)))                 }                 cursor.close()             }         }     }</code></pre><p>查询时，按时间接收时间降序查找就可以获取，最新接收的短信了。</p></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://developer.android.com/reference/android/provider/Telephony" target="_blank" rel="noopener">Telephony</a></li><li><a href="https://developer.android.com/reference/android/telephony/SmsManager" target="_blank" rel="noopener">SmsManager</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;  最近的开发中，需要调用系统API来进行短信发送，当接受到短信时需要将短信内容读取出来。根据官方的相关文档成功实现了，在这做一个简要的记录
      
    
    </summary>
    
      <category term="Android" scheme="http://www.korion.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.korion.cn/tags/Android/"/>
    
      <category term="开发笔记" scheme="http://www.korion.cn/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="SmsManager" scheme="http://www.korion.cn/tags/SmsManager/"/>
    
  </entry>
  
  <entry>
    <title>Android获取联系人信息</title>
    <link href="http://www.korion.cn/2018/05/10/Android-%E8%8E%B7%E5%8F%96%E8%81%94%E7%B3%BB%E4%BA%BA%E4%BF%A1%E6%81%AF/"/>
    <id>http://www.korion.cn/2018/05/10/Android-获取联系人信息/</id>
    <published>2018-05-10T08:23:54.000Z</published>
    <updated>2018-05-10T08:23:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>  Android如何获取通讯录中联系人的信息?</p><h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><ul><li>ContactsContract</li><li>ContentResolver</li><li>动态权限申请</li><li>一点SQL语法基础</li></ul><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>  在Android中获取通讯录联系人信息其实比较简单，只要通过ContentResolver来查询相关URI的数据库表就可以了。</p><h4 id="三张表"><a href="#三张表" class="headerlink" title="三张表"></a>三张表</h4><p>  Android 将我们的联系人信息存储在三张表中，</p><ul><li><p><a href="https://developer.android.com/reference/android/provider/ContactsContract.Contacts" target="_blank" rel="noopener">ContactsContract.Contacts</a><br>每一行表示通讯录中的一个联系人。</p></li><li><p><a href="https://developer.android.com/reference/android/provider/ContactsContract.RawContacts" target="_blank" rel="noopener">ContactsContract.RawContacts</a><br>每个联系人记录的元数据。</p></li><li><p><a href="https://developer.android.com/reference/android/provider/ContactsContract.Data" target="_blank" rel="noopener">ContactsContract.Data</a><br>联系人信息实际保存在该表中, 包括联系人的名字，手机号，邮箱等。</p></li></ul><p>因为Android系统中，可以登录多个帐户进行通讯录同步，所以一个联系人可能来自不同的帐号中，所以需要ContactsContract.RawContacts表记录，联系人信息中，那哪些信息来自哪个帐户，该记录什么时候进行的同步，同步下来后，是否发生过修改等信息，这些信息我们一般不需要关注。</p><h4 id="三张表的关系"><a href="#三张表的关系" class="headerlink" title="三张表的关系"></a>三张表的关系</h4><p>  这三张表的关系用ER图表示:</p><p>  <img src="https://i.loli.net/2018/05/11/5af55a5ec168a.png" alt="Android联系人数据库表.png"></p><p>了解了这个三个表的关系之后，获取所有联系人的信息的思路就明确了。</p><blockquote><ol><li>查询Contacts表中的所有记录，获取_ID.</li><li>查询RawContacts表中CONTACT_ID为 步骤1中_ID 的所有记录，获取_ID.</li><li>查询Data表中RAW_CONTACT_ID为 步骤2中_ID 的所有记录，获取所需要的信息。</li></ol></blockquote><p> 实际上，就是做这三个表的级联查询。</p><h4 id="CommonDataKinds"><a href="#CommonDataKinds" class="headerlink" title="CommonDataKinds"></a>CommonDataKinds</h4><p>  除了上面三张表之外，这里还要了解一下<a href="https://developer.android.com/reference/android/provider/ContactsContract.CommonDataKinds.html" target="_blank" rel="noopener">ContactsContract.CommonDataKinds</a>。<br>  上文中三张表分别封装为对应的三个类，而CommonDataKinds封装的是这几个表中的某些列的别名。比如Data表中，数据存放在DATA1，DATA2，…， DATA15这几个列中，而CommonDataKinds.PHONE.NUMBER，实际就是指向了DATA1.</p><p>  它存在的意义在于方便我们进行信息的提取。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ol><li><p>添加相关权限</p><pre><code> &lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot; /&gt;</code></pre><p>注: 该权限为危险，Android6.0以上需要进行动态申请</p></li><li><p>代码</p><pre><code> //kotlin //获取所有联系人名字和Id public fun getAllContacts(contentResolver: ContentResolver): List&lt;SimpleContactsInfo&gt;?{     val col = arrayOf(ContactsContract.Contacts._ID,             ContactsContract.Contacts.DISPLAY_NAME_PRIMARY)     val cursor = contentResolver.query(ContactsContract.Contacts.CONTENT_URI,             col, null, null, null)     if (cursor != null){         while (cursor.moveToNext()){             val id = cursor.getInt(cursor.getColumnIndex(ContactsContract.Contacts._ID))             val name = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME_PRIMARY))             Log.d(TAG, &quot;\nID = &quot;+id+&quot; name = &quot;+name)             getRawContacts(contentResolver, id)             Log.d(TAG, &quot;\n----------------------------------------------&quot;)         }         cursor.close()     }     return null } //获取该联系人所有元数据 public fun getRawContacts(contentResolver: ContentResolver, contactId: Int){     val col = arrayOf(ContactsContract.RawContacts._ID,             ContactsContract.RawContacts.CONTACT_ID,             ContactsContract.RawContacts.ACCOUNT_NAME)     val cursor = contentResolver.query(ContactsContract.RawContacts.CONTENT_URI,             col, ContactsContract.RawContacts.CONTACT_ID+&quot; = ?&quot;,             arrayOf(contactId.toString()), null)     if(cursor != null){         while (cursor.moveToNext()){             val id = cursor.getInt(cursor.getColumnIndex(col[0]))             val contact_id = cursor.getInt(cursor.getColumnIndex(col[1]))             val accountName = cursor.getInt(cursor.getColumnIndex(col[2]))             Log.d(TAG, &quot;\nID = &quot;+id+&quot; contactId = &quot;+contact_id+&quot; accountName = &quot;+accountName)             getContactData(contentResolver, id)         }         cursor.close()     } } //获取该元数据对应用的数据 public fun getContactData(contentResolver: ContentResolver, rawContactId: Int){     val col = arrayOf(ContactsContract.Data._ID,             ContactsContract.CommonDataKinds.StructuredName.DISPLAY_NAME,             ContactsContract.CommonDataKinds.Phone.NORMALIZED_NUMBER)     val cursor = contentResolver.query(ContactsContract.Data.CONTENT_URI,             null, ContactsContract.Data.RAW_CONTACT_ID+&quot; = ?&quot;,             arrayOf(rawContactId.toString()), null)     if(cursor != null){         while (cursor.moveToNext()){             val id = cursor.getInt(cursor.getColumnIndex(col[0]))             val name = cursor.getString(cursor.getColumnIndex(col[1]))             val number = cursor.getString(cursor.getColumnIndex(col[2]))             Log.d(TAG, &quot;\nDataId = &quot;+id+&quot; name = &quot;+name+&quot; number = &quot;+number)         }         cursor.close()     } }</code></pre></li></ol><p>除此之外，google还提供给 ContactsContract.Contacts.Entity，方便我们通过联系人Id查询对应的信息实体，避免多次查询表，然而我试了一下，在我的机器上没有成功。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.android.com/guide/topics/providers/contacts-provider" target="_blank" rel="noopener">https://developer.android.com/guide/topics/providers/contacts-provider</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;  Android如何获取通讯录中联系人的信息?&lt;/p&gt;
&lt;h3 id=&quot;相关知识&quot;&gt;&lt;a href=&quot;#相关知识&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Android" scheme="http://www.korion.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.korion.cn/tags/Android/"/>
    
      <category term="开发笔记" scheme="http://www.korion.cn/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ContactsContract" scheme="http://www.korion.cn/tags/ContactsContract/"/>
    
  </entry>
  
  <entry>
    <title>AS替换Window终端为bash</title>
    <link href="http://www.korion.cn/2018/05/06/AS-%E6%9B%BF%E6%8D%A2Window%E7%BB%88%E7%AB%AF%E4%B8%BAbash/"/>
    <id>http://www.korion.cn/2018/05/06/AS-替换Window终端为bash/</id>
    <published>2018-05-06T04:17:00.000Z</published>
    <updated>2018-05-06T04:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>  现在，基本上Android开发使用的IDE都是Android Studio，Android Studio既美观又强大。不过，在Windows平台下，AS中使用的Terminal默认是Windows的Cmd，用着体验很不好，自动补齐都没有，使用git相关命令时，特别不方便。（Linux、Mos请无视）</p><p>  所以，今天试着将Terminal替换成<a href="https://git-scm.com/" target="_blank" rel="noopener">Git for windows</a>的bash。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>安装Git for window</p><p>到<a href="https://git-scm.com/" target="_blank" rel="noopener">官网</a>上下载，对应的版本（.exe），安装过程略。安装时记住安装路径就可以了。</p><p>默认安装路径:C:\Program Files\Git</p></li><li><p>在AS中进行修改Terminal指向bash</p><p>File-&gt; settings -&gt; Tools -&gt; Terminal</p><p>修改Shell path为Git安装目录下的\bin\bash.exe, 如图，</p><p><img src="https://i.loli.net/2018/05/06/5aee88c2d37e2.png" alt="TIM图片20180506124528.png"></p><p>关掉原来的Terminal，再启动就是bash了。</p><p><strong>Ok！搞定</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;p&gt;  现在，基本上Android开发使用的IDE都是Android Studio，Android Studio既美观又强大。不过，在Windo
      
    
    </summary>
    
      <category term="开发工具" scheme="http://www.korion.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Android Studio" scheme="http://www.korion.cn/tags/Android-Studio/"/>
    
      <category term="Bash" scheme="http://www.korion.cn/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>五一干了些啥</title>
    <link href="http://www.korion.cn/2018/05/02/%E4%BA%94%E4%B8%80%E5%B9%B2%E4%BA%9B%E5%95%A5/"/>
    <id>http://www.korion.cn/2018/05/02/五一干些啥/</id>
    <published>2018-05-01T16:25:45.000Z</published>
    <updated>2018-05-01T16:25:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>   今年的五一连同周末，只放了三天假。最近这段时间，自己一直不在状态，至于为啥不在状态，可能是因为自从拿到实习offer后，没有什么压力有关吧。另一方面，自己期待的事情也没有如愿进行，某人再也不联系我，以前天天聊得还开心，直到某天，我在找不到对方感兴趣的事情，于是慢慢就没有怎么联系了。唉！</p><p>   不过，这些都不应该成为自己变得懒散的原因吧。最近一直是一种咸鱼的状态，上课不听，看书学习不专注，出去玩也没有啥兴趣。前天晚上，和妹妹视频聊天后，她很担忧的和我说，要有活力一点。emm…，我看起来有那么负能量么？</p><p>   假期这几天，打了不少游戏，还看两部电影《环太平洋2》还有《金刚:骷髅岛》，尽管一开始就有心理准备，不过看完这两部后，还是感觉有点失望，可能是对前作评价比较高吧。具体为啥失望，我就不展开了，因为我不是专业的影评。</p><p>   (其实是因为我懒，不想为了表达内心的吐槽，思考如何去表达。^_^)</p><p>   昨天，在B站上了解到了《Unnatural》,是一部关于非自然死亡的日剧，剧中的主角们（法医）通过解剖死者的尸体，查明其真正的死因，揭露隐藏在死亡背后的案件真相。总体的观感挺错的，剧情不拖沓，基本上每一集都是一个独立的案件，但有不缺乏转折，第一集60分钟的剧情，就有两处大转折。另外，从开头的故事，就一直穿插着一个名为”红色金鱼”的暗线，作为故事最后的boss剧情线，好像这是日剧的惯用方式。再之，就是有的故事实际上是反映了现实。嗯~，我一向就比较喜欢这种能够反映现实同时又能引起观众的思考，或者对某些事物的关注的作品。<br>   于是，今天，我花了一天时间把10集一口气看完了。。。嘿嘿。之前国内的热播剧《法医秦明》好像也是这类电视剧，不过我没有看过，有机会去翻出来看看。@_@</p><p>   这几天要说一点都没有学习倒也不是，好歹第一天待在实验室，看了一点书，还在LintCode上刷了几道题。（自我安慰一下Y_Y）</p><p>   不过，令我感触最大的还是，了解到了有很优秀的同学，一直都很努力，也很厉害。具体多厉害，可以看看她的blog。<a href="https://www.zuozuovera.com/" target="_blank" rel="noopener">Click Here</a></p><p>   唉，每隔一段时间，我都会去反思后自己的所作，值得吗？时间匆匆过隙，流失的时间无法挽回，休闲过后，是该回归奋斗的主题了！Fighting！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   今年的五一连同周末，只放了三天假。最近这段时间，自己一直不在状态，至于为啥不在状态，可能是因为自从拿到实习offer后，没有什么压力有关吧。另一方面，自己期待的事情也没有如愿进行，某人再也不联系我，以前天天聊得还开心，直到某天，我在找不到对方感兴趣的事情，于是慢慢就没
      
    
    </summary>
    
      <category term="日常" scheme="http://www.korion.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>Git常用命令</title>
    <link href="http://www.korion.cn/2018/04/11/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.korion.cn/2018/04/11/Git常用命令/</id>
    <published>2018-04-11T08:15:28.000Z</published>
    <updated>2018-04-11T08:15:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Git是我们开发者常用的、便捷的分布式版本控制工具，它既可以创建本地管理仓库，也可以同步远程仓库上，在合作开中充当着重要角色。熟练使用Git有利于我们的开发和代码维护，但是由于本人常常忘记一些命令，所以在这对开发中容易忘记的命令进行记录。</p><p>关于Git的使用教程，推荐廖雪峰老师教程:<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">《Git教程》</a></p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>Git命令格式:<br>git &lt;command> [&lt;revision>…] – [&lt;file>…]</p><p>Git中工作区、暂存区、版本库、远程仓库：</p><ul><li><p>工作区: git init命令初始化的目录，通常就是工程的根目录（比如，./gitProject），git init命令执行完后，会在工作区目录下生成.git目录（./gitProject/.git）。</p></li><li><p>暂存区: 存放git add命令提交的文件，git add 命令执行完后，文件的记录首先会被添加到暂存区，表示对这个文件进行版本控制。</p><ul><li>git status： 查看暂存区的记录，以及工作区中哪些文件被修改.</li><li>git diff: 查看暂存区和工作区中哪些文件做了哪些修改. (git diff – <file>)</file></li><li>git rm –cached file: 删除暂存区中的文件记录。</li></ul></li><li><p>版本库: 记录git commit命令提交的记录，每个记录保存着一个版本的文件。所有提交记录形成一个链状的版本库。</p><ul><li>git log: 查看commit历史记录</li><li>git reflog: 查看对版本库的操作记录，包括commit、reset</li><li>git reset –hard commit_id: 回滚到commit_id版本，同时产生一次reset记录</li><li>git rm file: 从版本库中删除一个文件，这意味着不对该文件进行版本控制</li></ul></li><li><p>远程仓库: 比如<a href="https://github.com/" target="_blank" rel="noopener">Github</a>、<a href="https://gitee.com/" target="_blank" rel="noopener">码云</a>上面的仓库…</p><ul><li>git remote -v: 查看远程仓库地址</li></ul></li></ul><p>分支: Git支持多分支管理，每个分支相对独立，每个分支有各自的提交记录，分支的存在便于不同功能模块的并行开发。Git默认的主分支为master。</p><ul><li>git branch: 查看分支，’*‘ 表示当前所在分支。</li></ul><p>HEAD: HEAD是版本库中一个指向当前分支当前版本的一个指针（表示当前版本），默认指向git log中最新的版本。</p><ul><li>HEAD^: 表示上一个版本记录.（HEAD^^、HEAD^^^依次类推）</li><li>HEAD~1: 表示上一个版本记录.(HEAD~n, n=1,2,3,… 依次类推)</li></ul><h4 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4><ol><li>git checkout</li></ol><blockquote><p>git checkout – <file>  从暂存区恢复指定文件到工作区</file></p><p>git checkout – .       从暂存区恢复已经缓存的文件到工作区</p><p>git checkout HEAD <file>  从HEAD指向的版本中恢复指定文件到工作区和暂存区</file></p><p>git checkout HEAD .       从HEAD指向的版本中恢复已经提交的文件到工作区和暂存区</p></blockquote><ol><li>git reset</li></ol><blockquote><p>git reset HEAD <file> 撤销已add暂存区的记录，不影响工作区的文件</file></p><p>git reset HEAD .</p><p>git reset –hard HEAD^ 回滚到上个版本，撤销缓存区，影响工作区</p></blockquote><h4 id="分支控制"><a href="#分支控制" class="headerlink" title="分支控制"></a>分支控制</h4><ol><li><p>git branch</p><p>查看所有分支, “*“表示当前所在分支。</p><p>-d: 删除某个分支</p></li><li><p>git checkout &lt;branch_name&gt;</p><p>切换到分支</p><p>-b: 创建并切换到某个分支</p></li><li><p>git merge &lt;branch_name&gt;</p><p>将某分支合并到当前分支</p></li></ol><h4 id="远程仓库-amp-同步"><a href="#远程仓库-amp-同步" class="headerlink" title="远程仓库&amp;同步"></a>远程仓库&amp;同步</h4><ol><li><p>git remote -v</p><p>查看远程仓库地址</p></li><li><p>git remote add &lt;仓库别名&gt; &lt;仓库url&gt;</p><p>添加远程仓库</p><p>git remoet set-url &lt;仓库别名&gt; &lt;仓库url&gt;</p><p>修改远程仓库url</p></li><li><p>git push &lt;仓库别名&gt; &lt;分支&gt;</p><p>同步某分支到远程仓库</p><p>git push -f &lt;仓库别名&gt; &lt;分支&gt;</p><p>强制同步某分支到远程仓库，覆盖远程仓库. 很实用，很危险</p></li></ol><h3 id="持续更新-2018-4-11"><a href="#持续更新-2018-4-11" class="headerlink" title="持续更新: 2018/4/11"></a>持续更新: 2018/4/11</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Git是我们开发者常用的、便捷的分布式版本控制工具，它既可以创建本地管理仓库，也可以同步远程仓库上，在合作开中充当着重要角色。熟练使用Git
      
    
    </summary>
    
      <category term="开发工具" scheme="http://www.korion.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://www.korion.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载机制</title>
    <link href="http://www.korion.cn/2018/04/07/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.korion.cn/2018/04/07/Java类加载机制/</id>
    <published>2018-04-07T11:30:41.000Z</published>
    <updated>2018-04-07T11:30:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>  Java虚拟机将类的数据从Class文件中加载到内存中，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程，称为类加载。</p><p>  PS：Class文件指描述了一个类的结构的、具有特定构造的二进制字节串，可以是磁盘上的class文件，也可以是网络上的字节流。</p><p>  本文主要内容：</p><ol><li>类的生命周期</li><li>类加载的几个过程</li><li>类加载器</li><li>双亲委派模型</li></ol><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>  类从被加载到虚拟机内存到卸载出内存，包括以下几个过程：<br>  <img src="https://i.loli.net/2018/04/07/5ac8b410d47be.png" alt="Java类加载.png"></p><h4 id="类加载的几个过程"><a href="#类加载的几个过程" class="headerlink" title="类加载的几个过程"></a>类加载的几个过程</h4><ol><li><p>加载</p><p>该过程是类加载的第一个过程，在该阶段，虚拟机需要干一下三件事：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ul><p>在这个阶段，可以使用系统提供的类引导加载器来完成，也可以通过自定义的类加载器完成。重写一个类加载群的loadClass()方法去控制字节流的获取方式。</p><p>PS:数组类不通过类加载进行创建，而是由Java虚拟机直接创建。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需格式存储在方法区之中，然后再方法区中实例化一个Class类对象。（类的加载过程和连接阶段的部分过程是交叉的。）</p></li><li><p>验证</p><p>该阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。（文件格式验证、 元数据验证、 字节码验证、 符号引用验证）</p></li><li><p>准备</p><p>该阶段正式为类变量分配内存并设置类变量的初始化值。这里所说的变量为类静态变量，初始值是指类型的默认值，比如int为0、boolean为false。不是在类中显式指定的初始化值。（类的初始化值，会有有虚拟机自动生成的类构造器&lt;clinit>()方法进行赋值）</p></li><li><p>解析</p><p>该阶段主要完成将类中的符号引用（类名、字段名、方法名）替换为直接引用（指针、相对偏移量或一个能定位到目标的句柄），包括类或接口的解析、字段解析、类的方法解析，最终将类或接口、字段和方法的引用替换成对内存位置的直接引用。</p></li><li><p>初始化</p><p>该阶段虚拟机通过执行&lt;clinit>()方法对类中的变量或者资源进行初始化。</p><ul><li>&lt;clinit>()方法</li></ul><p>&lt;clinit>()方法是由编译器收集类中的所有类变量赋值动作和静态语句块（static{}块）中的语句合并产生的。</p><p>&lt;clinit>()方法不需要显示地调用父类的构造器，虚拟机的类初始化规则保证了执行子类的<clinit>()方法前，父类的&lt;clinit>()方法已经被执行完成。</clinit></p><p>接口中的不能使用静态语句块，但是如果接口有赋值操作，同样会生成一个&lt;clinit>()方法.</p><p>虚拟机会保证一个类的&lt;clinit>方法在多线程环境中被正确地加锁、同步，确保线程安全。同一个类加载器下，一个类的&lt;clinit>()只会被执行一次。</p><ul><li>必定会初始化的情况</li></ul><p>1）new创建一个类实例、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候，如果类没有进行初始化，则需要触发其初始化。</p><p>2）使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行初始化，则需要触发其初始化。</p><p>3）当初始化一个类时，发现其父类没有初始化，则需要先初始化其父类。</p><p>4）当虚拟机启动时，虚拟机会初始化包含mian()的那个类。</p></li></ol><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>  完成”通过一个类的全限定名来获取描述此类的二进制字节流”这个动作的代码模块称为类加载器。</p><p>  类加载不仅仅实现了类的加载动作，对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，即比较两个类是否”相等”（Class对象的equels()、instanceof、isInstance()、isAssignableFrom()返回的结果），要在这两个是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来自同一个Class文件，被同一个虚拟机加载，如果由不同的类加载器加载，也不能算相等。</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>Java中包括了3种系统提供的类加载器：</p><ul><li>启动类加载器：由C++编写，用于系统启动时，将系统类库（&lt;JAVA_HOME>\lib目录）加载到内存中。不能被Java程序直接使用。</li><li>扩展类加载器：由ExtClassLoader实现，负责加载&lt;JAVA_HOME>\lib\ext目录中的类库，<br>可以直接使用。</li><li>应用程序类加载器：由ClasLoader实现,这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以也称为系统类加载器。一般情况下，都是使用这个类进行加载。</li></ul><p><img src="https://i.loli.net/2018/04/08/5ac9022f8f3e6.png" alt="Java类加载双亲委派模型.png"></p><p>类加载器之间，通过组合方式形成了如图的层次结构，该结构称为双亲委派模型.</p><p>在该模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给上层的类加载器去完成，每一层都是如此，因此所有的类加载请求最终都应该传送到顶层的启动类加载器中，只有上层的类加载器反馈无法完成该类的加载时，才会尝试自己去加载。</p><p>如果用户写了一个类的全类名和系统API中的某个类一样，那么根据双亲委派模型，应该加载那个先加载的类–系统API的类.</p><p>PS：双亲委派模型不是强制性的，因此可以直接自定义ClassLoader加载自己的类。</p><p>参考:《深入理解Java虚拟机》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;  Java虚拟机将类的数据从Class文件中加载到内存中，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的
      
    
    </summary>
    
      <category term="Java" scheme="http://www.korion.cn/categories/Java/"/>
    
    
      <category term="虚拟机" scheme="http://www.korion.cn/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="Java" scheme="http://www.korion.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin:告别findViewById</title>
    <link href="http://www.korion.cn/2018/03/31/Kotlin%E5%91%8A%E5%88%ABfindViewById/"/>
    <id>http://www.korion.cn/2018/03/31/Kotlin告别findViewById/</id>
    <published>2018-03-31T08:29:55.000Z</published>
    <updated>2018-03-31T08:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>关于Kotlin，个人在Google发布前就已经关注了，前段时间曾经看着文档学了一些，但是一直没有没有项目中使用。最近上学校里面的移动应用开发课，需要写一些小作业，索性拿作业来练练手。</p><h3 id="告别findViewById"><a href="#告别findViewById" class="headerlink" title="告别findViewById"></a>告别findViewById</h3><p>相信很多人都对Android开发中，使用findViewbyId来获取布局的中控件感到繁琐，好在有ButterKnife这样神奇的第三方依赖注入库，让我们能够减少很多模板代码。不过当你使用Kotlin进行开发时，Kotlin官方已经开发了<a href="https://kotlinlang.org/docs/tutorials/android-plugin.html" target="_blank" rel="noopener">Kotlin Android Extensions</a>(kotlin-gradle-plugin的一部分),帮我们完成控件绑定的任务。</p><h4 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h4><ol><li><p>配置Module的build.gradle</p><p>如果你的工程是Kotlin工程，那么只需在需要的Module的build.gradle中，添加</p><blockquote><p>apply plugin: ‘kotlin-android-extensions’</p></blockquote></li><li><p>在Activity的源代码中，引入相应的synthetic properties</p><blockquote><p>import kotlinx.android.synthetic.main.&lt;layout>.*</p></blockquote><p>&lt;layout>为布局文件名。比如</p><pre><code> //MainActivity.kt import kotlinx.android.synthetic.main.activity_main.* class MainActivity : AppCompatActivity() {   override fun onCreate(savedInstanceState: Bundle?) {   super.onCreate(savedInstanceState)   setContentView(R.layout.activity_main)   tv_name.text = &quot;Ksxy&quot;   } } //activity_main.xml &lt;TextView android:id=&quot;@+id/tv_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt;</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;关于Kotlin，个人在Google发布前就已经关注了，前段时间曾经看着文档学了一些，但是一直没有没有项目中使用。最近上学校里面的移动应用开
      
    
    </summary>
    
      <category term="Android" scheme="http://www.korion.cn/categories/Android/"/>
    
    
      <category term="开发笔记" scheme="http://www.korion.cn/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Kotlin" scheme="http://www.korion.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android开发杂记</title>
    <link href="http://www.korion.cn/2018/03/31/Android%E5%BC%80%E5%8F%91%E6%9D%82%E8%AE%B0/"/>
    <id>http://www.korion.cn/2018/03/31/Android开发杂记/</id>
    <published>2018-03-31T07:57:45.000Z</published>
    <updated>2018-05-05T07:57:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在开发的过程，有些比较琐碎的细节，由于容易忘记，每次使用到的时候都需要Google或者百度，相当麻烦，不如花点时间进行记录。</p><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><h4 id="Assets目录"><a href="#Assets目录" class="headerlink" title="Assets目录"></a>Assets目录</h4><p>Assets目录位于main/assets,和res目录同级别，在assets目录中的文件资源不会被编译，而是直接打包。在代码中引用其中的资源需要借助<strong>AssetManager</strong>。使用Context.getAssetManager()可以获取实例。</p><p>注：assets下可以有子目录，引入文件时url的根目录为assets。</p><pre><code>    val assets = getAssetManager()    val inStream = assets.open(&quot;img/qrcode.png&quot;)   //文件路径:assets/img/qrcode.png    val bitmap = BitmapFactory.decodeStream(inStream)    inStream.close()</code></pre><h4 id="string-xml中字符串插值"><a href="#string-xml中字符串插值" class="headerlink" title="string.xml中字符串插值"></a>string.xml中字符串插值</h4><blockquote><p>string.xml中，</p><p>   &lt;string name=”stu_name”>名字: %s&lt;/string></p><p>代码中，</p><p>tv_name.text = String.format(getResource().getString(R.string.stu_name), “Mr.chen”)</p></blockquote><ul><li>%n$ms：代表输出的是字符串，n代表是第几个参数，设置m的值可以在输出之前放置空格</li><li>%n$md：代表输出的是整数，n代表是第几个参数，设置m的值可以在输出之前放置空格</li><li>%n$mf：代表输出的是浮点数，n代表是第几个参数，设置m的值可以控制小数位数，如m=2.2时，输出格式为00.00</li><li>%d ：   表示整数<ul><li>%f：  表示浮点数</li><li>%s  ： 表示字符串</li></ul></li></ul><h4 id="ListView隐藏scrollbar"><a href="#ListView隐藏scrollbar" class="headerlink" title="ListView隐藏scrollbar"></a>ListView隐藏scrollbar</h4><blockquote><p>android:scrollbars=”none”<br>或<br>ListView#setVerticalScrollBarEnabled(true);</p></blockquote><h4 id="沉浸式状态栏适配"><a href="#沉浸式状态栏适配" class="headerlink" title="沉浸式状态栏适配"></a>沉浸式状态栏适配</h4><p>第三方库: <a href="https://github.com/Zackratos/UltimateBar" target="_blank" rel="noopener">UltimateBar</a></p><h4 id="根据文件名，获取其资源ID"><a href="#根据文件名，获取其资源ID" class="headerlink" title="根据文件名，获取其资源ID"></a>根据文件名，获取其资源ID</h4><ul><li><p>获取状态栏高度:</p><pre><code>  resources.getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;)  val status_bar_height = resources.getDimensionPixelSize(statusBarHeightId)</code></pre></li></ul><h4 id="Android版本判断"><a href="#Android版本判断" class="headerlink" title="Android版本判断"></a>Android版本判断</h4><pre><code>     if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M){}</code></pre><h4 id="6-0-动态权限申请"><a href="#6-0-动态权限申请" class="headerlink" title="6.0 动态权限申请"></a>6.0 动态权限申请</h4><ul><li><p>危险权限</p><p>  可以通过ADB命令查看:</p><blockquote><p>adb shell pm list permissions -d -g</p></blockquote><p>  <a href="https://developer.android.com/guide/topics/security/permissions?hl=zh-CN#normal-dangerous" target="_blank" rel="noopener">官方相关文档</a></p></li><li><p>动态申请权限模板代码</p><pre><code>  if(ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED){          //如果没有获得该权限          if(ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.READ_CONTACTS)){              //如果需要向用户说明申请权限的理由              //shouldShowRequestPermissionRationale()在之前的权限申请中被拒绝，并且选择了不再询问时，返回true          }          //申请权限          ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.READ_CONTACTS), CONTACTS_PERMISSION_CODE)      }  override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) {      when(requestCode){          CONTACTS_PERMISSION_CODE -&gt; {              if (grantResults[0]  == PackageManager.PERMISSION_GRANTED){                  //申请成功              }else{              }              return          }      }      super.onRequestPermissionsResult(requestCode, permissions, grantResults)</code></pre><p>  }</p></li></ul><h4 id="Button-去除阴影"><a href="#Button-去除阴影" class="headerlink" title="Button 去除阴影"></a>Button 去除阴影</h4><blockquote><p>style=”?android:attr/borderlessButtonStyle”</p></blockquote><h3 id="持续更新-2018-5-19"><a href="#持续更新-2018-5-19" class="headerlink" title="持续更新 2018-5-19"></a>持续更新 2018-5-19</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在开发的过程，有些比较琐碎的细节，由于容易忘记，每次使用到的时候都需要Google或者百度，相当麻烦，不如花点时间进行记录。&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
      <category term="Android" scheme="http://www.korion.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.korion.cn/tags/Android/"/>
    
      <category term="开发笔记" scheme="http://www.korion.cn/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java垃圾回收</title>
    <link href="http://www.korion.cn/2018/03/30/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://www.korion.cn/2018/03/30/Java垃圾回收/</id>
    <published>2018-03-30T15:47:51.000Z</published>
    <updated>2018-03-30T15:47:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>  关于Java虚拟机的垃圾回收机制（GC）的学习笔记。</p><h4 id="主要记录"><a href="#主要记录" class="headerlink" title="主要记录"></a>主要记录</h4><ol><li>如何确定哪些对象可以回收？</li><li>Java中的四种引用</li><li>几种垃圾回收的算法思想</li></ol><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="对象是否存活"><a href="#对象是否存活" class="headerlink" title="对象是否存活"></a>对象是否存活</h4><p>  Java中的对象实例主要存在于Java虚拟机的堆中，在垃圾收集器对堆中的实例进行回收之前，首先要确定哪些对象还可以”存活”，哪些可以回收。关于Java虚拟机的内存模型可以查看<a href="https://offensiveyy.github.io/2018/03/30/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">该文章</a></p><h5 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h5><p>  在刚学Java的时候就知道了这种方法，该方法和C++中的智能指针的思想差不多，给对象添加一个引用计算器，每当有一个地方引用它时，计数器的值就加1；当连接失效时，计数器减1；当计数器的值为0时，表示该该对象不存在任何引用，因此需要被回收。</p><p>  该方法比较简单，但是不能解决对象之间互相循环引用的问题。比如，A对象引用B对象，而B对象引用了A对象，除此之外，A、B对象均无其他引用，那么把A、B对象看成一个整体，则这两个对象都应该被回收，而他们的引用计数器均不为0.</p><h5 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h5><p>  在该算法中，需要从一系列称为”GCRoots”的对象开始，以这些对象为起点，分析他的引用对象，然后从他引用的对象向下分析其引用的对象，所走过的路径称为引用链（最终形成一个个连通图）。当一个对象到GCRoots没有任何引用链（从GCRoots对象不可达），则证明此对象不可用。如果学过图论，相信很容易理解。</p><p>  <strong>哪些对象属于GCRoots对象？</strong></p><blockquote><ol><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中Native方法引用的对象</li></ol></blockquote><h4 id="Java中的四种引用"><a href="#Java中的四种引用" class="headerlink" title="Java中的四种引用"></a>Java中的四种引用</h4><p>在JDK1.2后，Java对引用的概念进行了扩充，引入了强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）。</p><ul><li>强引用：代码间普遍存在，如”Object obj = new Object()”中的obj。只要存在强引用，对象就不会被回收。</li><li>软引用：对应Java中的SoftReference类，描述一些<strong>有用但是非必需</strong>的对象，关联的对象会在系统将要发生内存溢出异常前，列入下次回收的名单中。</li><li>弱引用：对应Java中的WeakReference类, 描述<strong>非必须</strong>的对象，关联的对象会在下次内存回收时参与回收，无论内存是否足够。</li><li>虚引用：对应Java中的PhantomReference类最弱的一种引用，一个对象是否有虚引用的存在，完全不会对其生存构成影响，也无法通过虚引用来取得一个对象实例。为一对象设置虚引用的唯一目的就是在这个对象被会回收时收到一个系统通知。</li></ul><h4 id="几种垃圾回收算法思想"><a href="#几种垃圾回收算法思想" class="headerlink" title="几种垃圾回收算法思想"></a>几种垃圾回收算法思想</h4><h5 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1. 标记-清除算法"></a>1. 标记-清除算法</h5><p>  该算法包括”标记”和”清除”两个阶段：首先标记出所有需要回收的对象，在标记完后统一回收所有被标记的对象。<br>  该算法主要有两种不足：</p><ul><li>标记和清除两个过程的效率都不高；</li><li>标记清除后会产生大量不连续的内存碎片，空间碎片太多可能导致以后需要分配大对象时，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作。</li></ul><h5 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2. 复制算法"></a>2. 复制算法</h5><p>  该算法会把内存划分为大小相等的两块，每次只使用其中的一块，当这一块内存呢用完时，就将还存活的对象复制到另一快上，然后再把已使用的内存空间一次清理掉。</p><ul><li>优点：不需要考虑内存碎片，复制时只需移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</li><li>不足：内存缩小为原来的一半。</li></ul><p>但实际上，该算法主要用于新生代区域，而且不需要按照1:1的比分割空间。新生代的特点就是每次回收都会有大多数对象被回收，根据这个特点，可以将内存划分为一块比较大的Eden空间和两块比较小的Survivor空间（8:1:1），每次使用Eden和其中一个块Survivor。当回收时，将Eden和Survivor中还活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。当Survivor空间不够用时，可以借用老年代进行分配担保。</p><h5 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3.标记-整理算法"></a>3.标记-整理算法</h5><p>  该算法和标记-清除相类似，不过在标记对象后，需要将所有存活的对象都移动到一端，然后直接清除掉端边界以外的内存。<br>  由于老年代中对象的存活率比较高，所以老年代使用复制算法时需要进行的复制操作比较多，代价比较高，所以更适合标记-整理算法。</p><h5 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h5><p>  其实就是将堆划分为新生代和老年代，根据两者不同的特点使用不同的垃圾收集算法。在新生代中，每次垃圾回收都会有大批对象死去，只有少量存活，选用复制算法。而老年代中因为对象存活率高、没有额外的空间进行分配担保，必须使用“标记-清除”或者“标记-整理”算法进行回收。</p><p>  参考:《深入理解Java虚拟机》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;  关于Java虚拟机的垃圾回收机制（GC）的学习笔记。&lt;/p&gt;
&lt;h4 id=&quot;主要记录&quot;&gt;&lt;a href=&quot;#主要记录&quot; class=&quot;
      
    
    </summary>
    
      <category term="Java" scheme="http://www.korion.cn/categories/Java/"/>
    
    
      <category term="虚拟机" scheme="http://www.korion.cn/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="Java GC" scheme="http://www.korion.cn/tags/Java-GC/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机内存模型</title>
    <link href="http://www.korion.cn/2018/03/30/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.korion.cn/2018/03/30/Java虚拟机内存模型/</id>
    <published>2018-03-30T11:59:21.000Z</published>
    <updated>2018-03-30T11:59:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>最近在面试的过程中，被问及了关于Java虚拟机的问题，虽然以前自己有过大致的了解，但是面试时有些紧张，没有回忆上来。索性查阅后做个总结。</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h4><p><img src="https://i.loli.net/2018/03/30/5abe3b29a3406.png" alt="Java虚拟机内存模型.png"></p><ul><li><strong>程序计数器</strong>: 程序计数器是一块比较小的内存空间，记录了当前<strong>线程</strong>所执行的字节码的行号，和CPU中的指令计数寄存器类似。每个线程都有一个独立的程序计数器，互不影响。如果线程执行的是Java方法，那么计数器记录着的是正在执行的虚拟机字节码指令的地址，如果执行的为Native方法，计数器为空。</li></ul><ul><li><strong>Java虚拟机栈</strong>: Java虚拟机和程序计数器一样为线程私有，它的生命周期和线程相同。描述了Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、操作数栈、动态链接、方法口等信息。递归调用层数比较多时的，就有可能导致该部分内存的溢出（StackOverflowError）。</li></ul><ul><li><strong>本地方法栈</strong>: 本地方法栈和Java虚拟机栈功能类似，区别在一个前者为Native方法提供服务，后台为Java方法服务。</li></ul><ul><li><p><strong>Java堆</strong>: Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的区域，在虚拟机启动时创建。用于存放对象实例。同时Java堆也是垃圾收集器管理的主要区域。在分代收集算法中，Java堆还可以细分为: 新生代和老年代。根据新生代和老年代的不同特点，采用不同是收集算法。</p></li><li><p><strong>方法区(别名Non-Heap)</strong>: 方法区和Java堆一样是线程共享的，用于存储已被加载的类的信息、常量、静态变量、即时编译器编译后的代码等数据。类被加载后，会生成对应Class的实例，该实例同样保存在方法区。</p><ul><li>运行时常量池: 为方法区的一部分，Class文件除了有类的版本、字段、方法、接口等描述信息外，还有有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。</li></ul></li></ul><ul><li><strong>直接内存</strong>: 直接内存并不虚拟机运行时数据区的一部分。在JDK1.4之中新加入的NIO类，基于通道（Channel）和缓冲区（Buffer）的IO方式，就是使用了Native函数直接分配内存，然后通过一个存储在Java堆中的DirectByteBuffer对象对这个块内存进行操作。</li></ul><p>参考:《深入理解Java虚拟机》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;最近在面试的过程中，被问及了关于Java虚拟机的问题，虽然以前自己有过大致的了解，但是面试时有些紧张，没有回忆上来。索性查阅后做个总结。&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="http://www.korion.cn/categories/Java/"/>
    
    
      <category term="虚拟机" scheme="http://www.korion.cn/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="内存模型" scheme="http://www.korion.cn/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>图解Activity/Fragment生命周期</title>
    <link href="http://www.korion.cn/2018/03/13/Android-Activity-Fragment%E8%B6%85%E8%AF%A6%E7%BB%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://www.korion.cn/2018/03/13/Android-Activity-Fragment超详细生命周期/</id>
    <published>2018-03-13T06:02:14.000Z</published>
    <updated>2018-03-13T06:02:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>关于Activity和Fragment的生命周期，是每个Android开发者必须熟悉掌握的，最近在网上发现了一张超详细的关于这两者生命周期的图, 于是结合自己的理解进行了学习。</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>先上图，<a href="https://github.com/xxv/android-lifecycle" target="_blank" rel="noopener">来源</a><br><img src="https://i.loli.net/2018/03/13/5aa76bdd4d05c.png" alt="complete_android_fragment_lifecycle.png"></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li><p>经典的生命周期就赘述。从整个生命周期来说，onCreate和onDestroy是配对出现，分别在Activity创建与销毁时执行一次；onStart和onStop分别标识是否可见，可被多次调用；onResume和onPause分别标识是否在前台，同样可被多次调用。这里需要注意的是onPause，在从当前Activity启动另一个Activity时会，先调用当前Activity的onPause，然后才调用新启动的Activity的onCreate，当完成新Activity的启动后，才调用原来的Activity的Stop(),为了不造成启动卡顿，不能再onPause中做耗时的操作。</p></li><li><p>onSaveInstanceState()与onReStoreInstanceState()</p><p>这两个方法都不属于Activity的正常生命周期，也不保证一定会被调用。onSaveIntanceState()只有Activity”容易”被销毁时（比如内存不足可能被销毁），才会被调用；当Activity被重建时，系统会调用onRestoreInstanceState()来恢复已经保存的视图。</p><blockquote><p>《阿里Android开发手册》第三章第2条:</p><p>【推荐】Activity#onSaveInstanceState()方法不是 Activity 生命周期方法，也不保证<br>一定会被调用。它是用来在 Activity 被意外销毁时保存 UI 状态的，只能用于保存临<br>时性数据，例如 UI 控件的属性等，不能跟数据的持久化存储混为一谈。持久化存储<br>应该在 Activity#onPause()/onStop()中实行。</p></blockquote><p><a href="https://www.jianshu.com/p/89e0a7533dbe" target="_blank" rel="noopener">关于onSaveInstanceState的调用时机</a></p></li><li><p>onPostCreate()、onPostResume()</p><p>onPostCreate()在调用onStart() 和onRestoreInstanceState(Bundle)后调用，这意味着这时候大多数初始工作已经完成，而又还没有完全显示出来。有时候我需要在获取某个View的大小，在OnCreate中获取时，View还没有来得及测量，大小为0，所以我们可以在该方法中获取。onPostResume()也可以干类似的事情。</p></li><li><p>onContentChanged()</p><p>onContentChanged()是Activity中的一个回调方法，当Activity的布局改动即setContentView()或者addContentView()方法执行完毕时就会调用该方法。</p></li><li><p>onAttachedToWindow()</p><p>onAttachedToWindow是在第一次onDraw前调用的。也就是我们写的View在没有绘制出来时调用的，但只会调用一次。</p></li><li><p>onUserInteraction() ，onUserLeaveHint()</p><p>这两个同样不是Activity的正常生命周期函数。根据官方的介绍，onUserInteraction(),当Activity发生任何按触碰事件，就会调用，主要用来监视用户是否在与当前Activity进行交互。onUserLeaveHint(),用户离开当前Activity，比如按Home，Activity进入后台时调用,在调用onUserLeaveHint之前，会调用onUserInteraction。</p><p><strong>另外</strong>,如果使用FragmentActivity(AppCompatActivity继承于FragmentActivity),则还要注意以下两个回调：</p></li><li><p>onResumeFragments</p><p>该函数在onResume之后进行调用，官方文档里面介绍，FragmentActivity的onResume将分发给onResumeFragments。《阿里Android开发手册》推荐最迟在这个方法中调用FragmentTransaction#commit()，否则可能出现<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0616/3050.html" target="_blank" rel="noopener">状态丢失</a>的错误。</p><blockquote><p>《阿里Android开发手册》第三章第7条:</p><p>【 推 荐 】 添 加 Fragment 时 ， 确 保 FragmentTransaction#commit() 在<br>Activity#onPostResume()或者 FragmentActivity#onResumeFragments()内调用。<br>不要随意使用 FragmentTransaction#commitAllowingStateLoss()来代替，任何<br>commitAllowingStateLoss()的使用必须经过 code review，确保无负面影响。</p></blockquote></li><li><p>onAttachFragment</p><p>每当Fragment调用onAttach后调用该方法, 如果Fragment尚未调用onCreate，会在Fragment#onCreate前调用。</p></li></ol><p>关于Activity/Fragment的生命周期，我写了个Demo：<a href="https://gitee.com/ksxy/ActivityLifeCycleAnalysisDemo" target="_blank" rel="noopener">这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;关于Activity和Fragment的生命周期，是每个Android开发者必须熟悉掌握的，最近在网上发现了一张超详细的关于这两者生命周期的
      
    
    </summary>
    
      <category term="Android" scheme="http://www.korion.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.korion.cn/tags/Android/"/>
    
      <category term="Activity" scheme="http://www.korion.cn/tags/Activity/"/>
    
      <category term="Fragment" scheme="http://www.korion.cn/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>网络笔记之详解TCP（一）</title>
    <link href="http://www.korion.cn/2018/03/12/%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%AF%A6%E8%A7%A3TCP%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.korion.cn/2018/03/12/网络笔记之详解TCP（一）/</id>
    <published>2018-03-12T13:43:52.000Z</published>
    <updated>2018-03-12T13:43:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  最近一直在复习计算机网络，在回顾了IP与UDP后，终于来到了TCP。在计算机网络的课程上，我第一次对TCP有了比较深入的了解，但是一直没有做过总结，以至于忘了TCP的很多细节。所以本次复习打算将这些细节尽快地记录下来。了解TCP的具体细节，有助于我们基于UDP开发出符合具体的业务的私有协议。</p><h3 id="TCP白话简介"><a href="#TCP白话简介" class="headerlink" title="TCP白话简介"></a>TCP白话简介</h3><p>  TCP在运输层提供了面向连接、可靠的字节流服务。所谓面向连接就是在开发发送数据前，需要先建立一个端到端的连接，这一点类似于通过电话之前的拨号，直到对面接听才建立通话通道。所谓可靠性，就是指即使在网络不稳定的环境下，TCP仍然要保证传输数据的完整（网路断开的情况TCP也无能为力）。为了能够保证数据的可靠传输，TCP需要考虑的事情很多，比如数据被破坏、丢包、重复以及顺序混乱等，为此，TCP设计了校验和、序列号、确认重答、重发控制、连接管理及窗口控制等机制。</p><p>  PS：尽管TCP能保证数据的可靠传输，但在弱网的情况下，TCP的传输效率很低，所以在信号不是很好地方，数据加载很慢。所以，有时需要开发者基于UDP制定自己的控制协议。</p><h3 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h3><p>  TCP和UDP一样封装在一个IP数据报中，TCP首部的数据格式，<br>  <img src="https://i.loli.net/2018/03/12/5aa6745b4abec.png" alt="TCP首部.png"></p><p>  <strong>源端口(16bit)</strong>: 发送端的端口号;</p><p>  <strong>目的端口(16bit)</strong>: 接收端的端口号;</p><p>  <strong>序列号(32bit)</strong>: 表示发送数据包中TCP段第一个字节的序号，每发送一个数据报，该字段就累加发送的数据长度。该字段不会从0开始，而是在握手的过程确定一个初始序号(ISN),之后在该值上进行累积加。假设握手后主1第一个数据报的序号为A，包含的数据为a字节，那主机1在发送第二个数据报时，其序号为A+a。</p><p>  <strong>确认号(32bit)</strong>: 指下次应该接收的数据的第一个字节的序列号。主机1发送第一数据包后，如果主机2回了一个确认报，那么该确认报的确认号为A+a。如果主机1收到了确认号为B的确认报，可认为B序号之前的数据报全部被正常接收，这意味着如果发生了数据包缺失，确认序号会一直为缺失的那部分数据的确认序号。该字段只有当控制位中的ACK=1时，才有效。</p><p>  <strong>数据偏移(4bit)</strong>: 标识TCP数据报中数据偏离TCP开头的位置，可以看成是TCP首部的长度单位为字。</p><p>  <strong>保留位(6bit)</strong>: 当前没有意义。</p><p>  <strong>控制位(6bit)</strong>:</p><blockquote><p> URG = 1时，表示紧急指针有意义，需要处理。</p><p> ACK = 1时，表示确认号有意义，实际上除了第一个握手包，其他的包都为1。</p><p> PSH = 1时，表示应该将数据立即交给上层应用协议。默认存入TCP的数据缓存区。</p><p> RST = 1时，表示TCP连接存在异常，应该强制断开，不会有四次握手过程。</p><p> SYN = 1时，表示该数据报为握手报，连接建立后SYN=0.</p><p> FIN = 1时，表示今后不会再有数据进行传输，只有在断开连接的四次握手中才会出现。</p></blockquote><p>  <strong>窗口大小(16bit)</strong>: TCP在传输过程中一个次传输多少个字节的数据取决一个滑动窗口机制，该机制通过该值指明下次能接收的数据大小，该字段可以用于拥塞控制。或者自己的缓存区快满了，通知对方减慢数据的发送。由于TCP是全双工工作的，所以连接双方都有各自的滑动窗口。</p><p>  <strong>检验和(16bit)</strong>: 和UDP协议一样，表示整个TCP数据报的校验和，计算方法也和UDP一样，TCP的检验和为必选项。</p><p>  <strong>紧急指针(16bit)</strong>: URG = 1时有效，表示本报文段中紧急数据末尾相对序列号的偏移量，指明了紧急数据的结束位置。</p><h3 id="TCP三次握手与四次握手"><a href="#TCP三次握手与四次握手" class="headerlink" title="TCP三次握手与四次握手"></a>TCP三次握手与四次握手</h3><p>TCP三次握手的意义是建立一个连接，确认连接的两端都可用。</p><ol><li>主机A发送一个SYN=1的数据包，携带着A到B方向的ISN。</li><li>主机B收到数据包后，回了一个应答包（SYN=1，ACK=1），该应答同时也包含了B到A方向的ISN。</li><li>主机A回一个应答包（ACK=1），同时连接建立。</li></ol><p>TCP通过四次握手关闭连接。</p><ol><li>主机A向主机B发送一个FIN=1的握手包，表示以后不需要发数据了，关闭A到B方向上连接。</li><li>主机B收到数据报后，回一个应答吧。主机A收到后，连接处于半关闭状态（主机A任可以接受数据，并进行应答）。</li><li>传输完最后的数据后，主机B发送FIN=1的握手包，表示同样的意义。</li><li>主机A收到后，回一个应答包，然后等待2MSL后，断开连接。</li></ol><p><img src="https://i.loli.net/2018/03/12/5aa68bed94834.png" alt="TCP三次握手和四次握手.png"></p><p>注：主机A（主动关闭的一端）在发送完最后一个ACK包后，要等一个2MSL的时长。一方面，避免<br>主机B没有接收到ACK包，导致连接一直不关闭，因为如果主机B没有接收到ACK包，将重发FIN包，在2MSL的时间可以被主机A接受。另一方面，在2MSL期间，该连接的端口不能被其他程序使用，对于”迟到”的数据报都将被丢弃，避免了”迟到”数据包对新连接的影响。</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>由于TCP内容比较多，关于滑动窗口机制、慢启动机制、超时和重传机制等内容，后续进行记录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;  最近一直在复习计算机网络，在回顾了IP与UDP后，终于来到了TCP。在计算机网络的课程上，我第一次对TCP有了比较深入的了解，但是一直没
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://www.korion.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://www.korion.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP" scheme="http://www.korion.cn/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>网络笔记之浅谈UDP</title>
    <link href="http://www.korion.cn/2018/03/11/%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B5%85%E8%B0%88UDP/"/>
    <id>http://www.korion.cn/2018/03/11/网络笔记之浅谈UDP/</id>
    <published>2018-03-11T12:25:29.000Z</published>
    <updated>2018-03-11T12:25:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="UDP白话简介"><a href="#UDP白话简介" class="headerlink" title="UDP白话简介"></a>UDP白话简介</h3><p>UDP是一个简单的面向数据报的运输层协议，提供不可靠、无连接的传输服务，因为不用像TCP一样进行确认重传、拥塞控制，所以UDP的传输工程比较简单。在网络环境比较好的情况下，传输效率极高。</p><p><img src="https://i.loli.net/2018/03/11/5aa5225247f65.jpg" alt="UDP封装.jpg"></p><h3 id="UDP首部"><a href="#UDP首部" class="headerlink" title="UDP首部"></a>UDP首部</h3><p><img src="https://i.loli.net/2018/03/11/5aa522bba3750.jpg" alt="UDP头部.jpg"></p><h3 id="UDP校验和"><a href="#UDP校验和" class="headerlink" title="UDP校验和"></a>UDP校验和</h3><p>UDP和TCP的校验和计算方法和IP相类似（16bit字的二进制反码和），但是IP只需计算首部的校验和，而UDP和TCP需要计算整个数据报的校验和。因为IP只需要保证IP首部的正确性，那么在网络环境正常的情况下，就能正确传输，而UDP和TCP都是直接承载应用层的数据，所以需要确保数据的正确性。</p><p>另外，UDP数据报的长度可以是奇数字节，但是校验和算法是把若干16bit字相加，所以必要时需要在最后增加填充字节0.填充字节参与校验和的计算，但不进行传输。</p><p>其次，在计算校验和时，UDP数据报和TCP段还需要包含一个12byte的伪首部。伪首部包含了IP首部的一些字段，其目的是让UDP在进行校验的时候再次确认数据是否是正确到达目的地。</p><p><img src="https://i.loli.net/2018/03/11/5aa5236380231.jpg" alt="UDP伪首部.jpg"></p><p>在进行必要的填充和加上伪首部后（计算前UDP校验和字段为0），就可以进行二进制反码计算，计算结果如果是0，则填入全1.</p><p>UDP的校验和计算可选，如果接收到的UDP数据报校验和为0，则发送端没有计算校验和。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;UDP白话简介&quot;&gt;&lt;a href=&quot;#UDP白话简介&quot; class=&quot;headerlink&quot; title=&quot;UDP白话简介&quot;&gt;&lt;/a&gt;UDP白话简介&lt;/h3&gt;&lt;p&gt;UDP是一个简单的面向数据报的运输层协议，提供不可靠、无连接的传输服务，因为不用像TCP一样进行确认
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://www.korion.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://www.korion.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="UDP" scheme="http://www.korion.cn/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>网络笔记之IP报文首部</title>
    <link href="http://www.korion.cn/2018/03/11/%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E4%B9%8BIP%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8/"/>
    <id>http://www.korion.cn/2018/03/11/网络笔记之IP报文首部/</id>
    <published>2018-03-11T06:36:04.000Z</published>
    <updated>2018-03-11T06:36:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IP协议白话简介"><a href="#IP协议白话简介" class="headerlink" title="IP协议白话简介"></a>IP协议白话简介</h3><p>IP协议工作在TCP/IP网络模型的网际层，主要作用是为网络中的路由提供路由依据，其包括目的地（目的IP）、出发地（源IP），类似于邮递包裹上面快递单信息。给上层服务提供不可靠、无连接的传输服务。</p><p><strong>问题：为啥IP协议是不可靠、无连接的？</strong></p><p>首先，不可靠是指它不能保证IP数据报能成功到达目的地。IP协议仅提供尽力的传输服务。如果因为某些原因发生丢包，IP协议不会提供任何反馈。而IP协议也不需要提供多余的反馈，因为可靠性由上层的TCP协议提供，而错误反馈可以通过ICMP协议来提供。简单地说，就是专业的事由专门的协议来做，IP协议的专业就只是传输。</p><h3 id="IP首部"><a href="#IP首部" class="headerlink" title="IP首部"></a>IP首部</h3><p><img src="https://i.loli.net/2018/03/11/5aa4cefdae987.jpg" alt="IP报文头部结构.jpg"></p><h3 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a>字段说明</h3><ul><li><strong>版本(4bit)</strong>:IP报文所使用的IP版本，目前通常是4（IPV4）。</li><li><strong>首部长度(4bit)</strong>:IP报文首部的长度，单位为字，IPv4报文头部该字段通常为5, 5字=20byte</li><li><strong>服务类型TOC(8bit)</strong>:描述该数据包的上层服务类型，主要作用是给路由决策提供参考，比如，给不同服务设置优先级，那么路由时可以优先处理优先级高的数据报。</li><li><strong>长度(16bit)</strong>:整个IP数据报的长度，单位为byte。</li><li><strong>标识(16bit)</strong>:唯一地标识主机发送的每份数据报，通常每份发一份报文它的值就会加1,达到最大值后重置。（该字段通常被称为IPid，据说某些校园网的多终端检测机制可以通过统计该字段，来计算该字段在坐标系中的分布来判断是否为多终端上网）</li><li><strong>标志(3bit)</strong>、<strong>片偏移(13bit)</strong>:这两个字段和IP分片相关，从上面IP报文的长度字段可知，一个IP报文最长为65535byte，实际传输的数据通常大于这个值，所以需要分成多个数据报。实际传输时，是否需要分成多个数据报，还取决于数据数据链路层一个叫MTU的值–链路层一个数据帧的最大数据长度。<ul><li>标志的3个bit分别表示：保留位、不分片、更多的片；不分片该字段为010,分片则除了包含最后一片的数据报，其他的都为001。</li><li>如果不分片，片偏移没有意义；如果分片，该字段的值表示该片偏移原始数据开始处的位置，用于分片重组, IP标识相同的分片最终会被重组在一起。</li></ul></li><li><strong>生存时间TTL(8bit)</strong>: 该字段表示报文可以经过的最多路由器数，初始值由源主机设定（通常32或64），每进过一个路由器，该值减1，当为0时，将会被路由器丢弃，并向源主机发送ICMP报文。路由追踪命令就是基于该字段实现的。</li><li><strong>协议(8bit)</strong>:该数据报承载的上层协议类型。</li><li><strong>首部检验和(16bit)</strong>:该字段用于校验该报文的头部信息是否有误，有误的数据报会被丢弃。具体的计算方法是先将该字段置0，然后把首部分割为多个16bit的二进制，然后对他们进行二进制反码求和。最后将算出来的结果填入。校验时同样是使用的二进制反码求和。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;IP协议白话简介&quot;&gt;&lt;a href=&quot;#IP协议白话简介&quot; class=&quot;headerlink&quot; title=&quot;IP协议白话简介&quot;&gt;&lt;/a&gt;IP协议白话简介&lt;/h3&gt;&lt;p&gt;IP协议工作在TCP/IP网络模型的网际层，主要作用是为网络中的路由提供路由依据，其包括目的
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://www.korion.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://www.korion.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="IP" scheme="http://www.korion.cn/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>Https之SSL/TLS握手</title>
    <link href="http://www.korion.cn/2018/03/10/Https%E4%B9%8BSSL-TSL%E6%8F%A1%E6%89%8B/"/>
    <id>http://www.korion.cn/2018/03/10/Https之SSL-TSL握手/</id>
    <published>2018-03-10T13:02:48.000Z</published>
    <updated>2018-03-18T03:06:47.621Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTPS白话简介"><a href="#HTTPS白话简介" class="headerlink" title="HTTPS白话简介"></a>HTTPS白话简介</h3><p>  相信对于大多数开发人员，Https并不陌生，在http协议基础上套上一个加密解密的过程，就是Https，而完成加密解密的部分就是SSL(Secure Sockets Layer, 安全套字节层)。<br>  <a href="https://i.loli.net/2018/03/10/5aa3dc30b9086.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/10/5aa3dc30b9086.png" alt="https协议.png"></a></p><h3 id="关于TSL-SSL"><a href="#关于TSL-SSL" class="headerlink" title="关于TSL/SSL"></a>关于TSL/SSL</h3><p>  1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是没有发布；之后在1995年正式发布了SSL 2.0, 但很快发现严重漏；1996年，SSL 3.0版问世，并得到大规模应用。之后在1999年，由互联网标准化组织ISOC接管，并升级成为TSL(Transport Layer Security)。所以TSL和SSL是同一个协议。</p><h3 id="加密解密基本原理"><a href="#加密解密基本原理" class="headerlink" title="加密解密基本原理"></a>加密解密基本原理</h3><p>  TSL在不同的阶段使用了不同的加密方式。</p><p>  在握手阶段，使用的是公钥加，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。握手的主要目的是完成客户端与服务端之间的验证，同时约定一个随机密钥种子；</p><p>  在数据传输阶段，所用的加密方式为对称加密(AES)，经过握手阶段后，客户端和服务端保存着同一个密钥种，在之后的数据传输中，客户端和服务器端使用同一个密钥进行加密解密。同时，该密钥还被用于作为HMAC的key，用于数据完整性、可靠性的校验。</p><p>  <strong>问题：握手阶段，如何保证公钥不被篡改？</strong></p><p>  实际上，客户端一开始向服务端请求的是一个数字证书，数字证书中包含了公钥、该数字证书的签发机构、改签发机构的数字签名等信息。客户端通过检验证书的合法性来判断包含公钥是否可信。</p><p>  至于为啥数字证书的方案可行，这就要涉及到信息安全的理论知识了，这里不深入。签发证书的机构如果是权威机构CA，则该证书是CA证书，可信任。如果不是，则提示证书不可信。</p><p>  <strong>问题：为啥在数据传输阶段不用公钥加密？</strong></p><p>  因为公钥加密实际上就的非对称加密，非对称加密的数序理论依据导致了非对称加密的成本比较高，所以通常只用于少量数据的传输，而对称加密是通过非线性变换等方式实现的加密，加密成本比较低，性能相对非对称加密高。</p><h3 id="SSL-TLS握手"><a href="#SSL-TLS握手" class="headerlink" title="SSL/TLS握手"></a>SSL/TLS握手</h3><p>  从上面的原理可总结出SSL/TLS握手的过程：</p><ol><li>客户端向服务器端索要并验证公钥。</li><li>双方协商生成”对话密钥”。</li></ol><p><strong>握手详细过程</strong>：</p><p><a href="https://i.loli.net/2018/03/10/5aa3f5f34a00f.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/10/5aa3f5f34a00f.png" alt="SSL握手.png"></a></p><ol><li><p>客户端发出请求（ClientHello）</p><p>客户端先向服务器发出加密通信的请求，请求内容：<br>支持的协议版本（比如TLS 1.0版）、随机数A（用于生产对称密钥）、支持的加密方法（比如RSA公钥加密）。</p></li><li><p>服务器回应（SeverHello）</p><p>服务器收到客户端请求后，向客户端发出回应，回应内容：<br>确认使用的协议版本、随机数B、确认使用的加密方法、服务器证书。</p><p>如果服务器需要验证客户端身份，还回要求客户端提供证书，该证书通常需要提前安装。</p></li><li><p>客户端回应</p><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从证书中取出服务器的公钥。</p><p>然后发送回应服务器：随机数C（用服务器公钥进行加密）、编码改变通知（表示随后的信息都将用双方商定的加密方法和密钥发送）、客户端握手结束通知（表示客户端的握手阶段已经结束）。</p></li><li><p>服务器的最后回应</p><p>服务器收到客户端的随机数C之后，计算生成本次会话所用的”会话密钥”，向客户端回应：编码改变通知、服务器握手结束通知。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTTPS白话简介&quot;&gt;&lt;a href=&quot;#HTTPS白话简介&quot; class=&quot;headerlink&quot; title=&quot;HTTPS白话简介&quot;&gt;&lt;/a&gt;HTTPS白话简介&lt;/h3&gt;&lt;p&gt;  相信对于大多数开发人员，Https并不陌生，在http协议基础上套上一个加密解密
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://www.korion.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="https" scheme="http://www.korion.cn/tags/https/"/>
    
      <category term="计算机网络" scheme="http://www.korion.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
